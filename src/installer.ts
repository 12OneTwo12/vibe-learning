#!/usr/bin/env node
/**
 * VibeLearning Installer
 *
 * Automatically installs VibeLearning for various AI coding agents.
 * Usage: npx vibe-learning install [platform]
 */

import { existsSync, mkdirSync, writeFileSync, readFileSync, unlinkSync, rmSync } from "fs";
import { join } from "path";
import { homedir } from "os";

// ============================================================
// OpenCode Command File (minimal - for autocomplete discovery only)
// ============================================================

const OPENCODE_LEARN_COMMAND = `---
description: VibeLearning - spaced repetition learning while coding
argument-hint: [status|on|off|senior|after|pause|stats|report|unknowns|review]
---

# EXECUTE NOW

Parse \`$ARGUMENTS\` and execute the matching command:

## (empty) or \`status\` - Show Status
\`\`\`
mcp__vibe-learning__get_mode
mcp__vibe-learning__should_ask_question
\`\`\`
Display: senior mode on/off, after mode on/off, cooldown, consecutive skips

## \`on\` - Full Learning Mode (default)
\`\`\`
mcp__vibe-learning__set_mode(senior_enabled=true, after_enabled=true)
\`\`\`

## \`off\` - Turn Off
\`\`\`
mcp__vibe-learning__set_mode(senior_enabled=false, after_enabled=false)
\`\`\`

## \`senior\` or \`senior on\` - Enable Senior Mode
\`\`\`
mcp__vibe-learning__set_mode(senior_enabled=true)
\`\`\`

## \`senior off\` - Disable Senior Mode
\`\`\`
mcp__vibe-learning__set_mode(senior_enabled=false)
\`\`\`

## \`after\` or \`after on\` - Enable After Mode
\`\`\`
mcp__vibe-learning__set_mode(after_enabled=true)
\`\`\`

## \`after off\` - Disable After Mode
\`\`\`
mcp__vibe-learning__set_mode(after_enabled=false)
\`\`\`

## \`pause\` - Pause 1 Hour
\`\`\`
mcp__vibe-learning__set_mode(paused_until="<1 hour from now ISO>")
\`\`\`

## \`stats\` - Statistics
\`\`\`
mcp__vibe-learning__get_stats(period="month")
\`\`\`

## \`report\` - Weekly Report
\`\`\`
mcp__vibe-learning__get_report_data(period="week")
\`\`\`

## \`report month\` - Monthly Report
\`\`\`
mcp__vibe-learning__get_report_data(period="month")
\`\`\`

## \`unknowns\` - Unknown Unknowns
\`\`\`
mcp__vibe-learning__get_unknown_unknowns(period="month", limit=10)
\`\`\`

## \`review\` - Due Reviews
\`\`\`
mcp__vibe-learning__get_due_reviews(limit=5)
\`\`\`
`;

// ============================================================
// OpenCode Plugin Code (inlined for local installation)
// ============================================================

function getOpencodePluginCode(): string {
  return `/**
 * VibeLearning OpenCode Plugin (Local)
 * Auto-generated by vibe-learning installer
 */

import type { Plugin } from "@opencode-ai/plugin";
import * as path from "node:path";
import * as os from "node:os";
import * as fs from "node:fs";

const DB_DIR = ".vibe-learning";
const DB_FILENAME = "learning.db";

interface LearningStatus {
  unknownUnknowns: { count: number; first?: string };
  dueReviews: { count: number; first?: string };
  error?: string;
}

function getLearningStatus(): LearningStatus {
  try {
    const dbPath = path.join(os.homedir(), DB_DIR, DB_FILENAME);
    if (!fs.existsSync(dbPath)) {
      return { unknownUnknowns: { count: 0 }, dueReviews: { count: 0 } };
    }
    const Database = require("better-sqlite3");
    const db = new Database(dbPath, { readonly: true });
    try {
      const unknownsCount = db.prepare("SELECT COUNT(*) as count FROM unknown_unknowns WHERE explored = 0").get();
      const firstUnknown = db.prepare("SELECT concept_id FROM unknown_unknowns WHERE explored = 0 ORDER BY appearances DESC, first_seen DESC LIMIT 1").get();
      const today = new Date().toISOString().split("T")[0];
      const reviewsCount = db.prepare("SELECT COUNT(*) as count FROM concept_progress WHERE next_review IS NOT NULL AND next_review <= ?").get(today);
      const firstReview = db.prepare("SELECT concept_id FROM concept_progress WHERE next_review IS NOT NULL AND next_review <= ? ORDER BY next_review ASC LIMIT 1").get(today);
      return {
        unknownUnknowns: { count: unknownsCount?.count ?? 0, first: firstUnknown?.concept_id },
        dueReviews: { count: reviewsCount?.count ?? 0, first: firstReview?.concept_id }
      };
    } finally { db.close(); }
  } catch (error) {
    console.error("[VibeLearning] DB Error:", error);
    return { unknownUnknowns: { count: 0 }, dueReviews: { count: 0 }, error: String(error) };
  }
}

const CONFIG = { TOOL_THRESHOLD: 3, COOLDOWN_MS: 15 * 60 * 1000, MAX_CONCEPTS: 10, SIGNIFICANT_TOOLS: ["edit", "write", "bash"] };
let toolCount = 0, lastLearningPrompt = 0, recentConcepts: string[] = [];
let seniorEnabled = true, afterEnabled = true, lastSessionID: string | null = null;
const shownToastSessions = new Set<string>(); // Track sessions where we've shown the welcome toast
const injectedSeniorSessions = new Set<string>(); // Track sessions where we've injected senior prompt

const FILE_CONCEPTS = [
  { pattern: /test|spec|__tests__/i, concept: "unit-testing" },
  { pattern: /auth|login|session|jwt|oauth/i, concept: "authentication" },
  { pattern: /api|endpoint|route/i, concept: "api-design" },
  { pattern: /cache|redis|memcache/i, concept: "caching" },
  { pattern: /hook|use[A-Z]/i, concept: "react-hooks" },
  { pattern: /\\.tsx$|\\.jsx$/i, concept: "react-components" },
  { pattern: /db|database|prisma|sequelize|typeorm/i, concept: "database" },
];

function extractConceptFromPath(filePath: string): string | null {
  const lower = filePath.toLowerCase();
  for (const { pattern, concept } of FILE_CONCEPTS) {
    if (pattern.test(lower)) return concept;
  }
  return null;
}

function addConcept(concept: string): void {
  if (!recentConcepts.includes(concept)) {
    recentConcepts.push(concept);
    if (recentConcepts.length > CONFIG.MAX_CONCEPTS) recentConcepts.shift();
  }
}

const COMMAND_PROMPTS: Record<string, string> = {
  status: "Execute NOW: Call mcp__vibe-learning__get_mode and mcp__vibe-learning__should_ask_question, then show: Senior mode on/off, After mode on/off, Cooldown status, Consecutive skips",
  stats: "Execute NOW: Call mcp__vibe-learning__get_stats with period=\\"month\\", then format as a dashboard",
  report: "Execute NOW: Call mcp__vibe-learning__get_report_data with period=\\"week\\", then format as a report",
  "report-month": "Execute NOW: Call mcp__vibe-learning__get_report_data with period=\\"month\\", then format as monthly report",
  unknowns: "Execute NOW: Call mcp__vibe-learning__get_unknown_unknowns with period=\\"month\\" and limit=10, then show unknown concepts by priority",
  review: "Execute NOW: Call mcp__vibe-learning__get_due_reviews with limit=5. For each due concept, ask a level-appropriate question and record results.",
  pause: "Execute NOW: Call mcp__vibe-learning__set_mode with paused_until set to 1 hour from now (ISO format). Confirm paused.",
  off: "Execute NOW: Call mcp__vibe-learning__set_mode with senior_enabled=false and after_enabled=false. Confirm learning is off.",
  on: "Execute NOW: Call mcp__vibe-learning__set_mode with senior_enabled=true and after_enabled=true. Confirm full learning mode enabled.",
  "senior-on": "Execute NOW: Call mcp__vibe-learning__set_mode with senior_enabled=true. Confirm senior mode enabled.",
  "senior-off": "Execute NOW: Call mcp__vibe-learning__set_mode with senior_enabled=false. Confirm senior mode disabled.",
  "after-on": "Execute NOW: Call mcp__vibe-learning__set_mode with after_enabled=true. Confirm after mode enabled.",
  "after-off": "Execute NOW: Call mcp__vibe-learning__set_mode with after_enabled=false. Confirm after mode disabled.",
};

const SENIOR_BEHAVIOR_PROMPT = \`Ask ONE question per round. Minimum 2 rounds required.
Format: **[VibeLearning Senior Mode]** [Round 1/3] [Question]? _(skip: say "skip")_
After final round, call mcp__vibe-learning__record_learning and mcp__vibe-learning__record_unknown_unknown, then say "Good thinking! Implementing now."\`;

const AUTO_LEARNING_PROMPT = \`[VibeLearning - Task Completion]
Task completed. Execute: 1) Identify 1-3 key concepts, 2) Record unknown unknowns, 3) Call get_concept_level, 4) If should_ask_question returns true, ask a learning question.\`;

function parseLearnCommand(text: string): string | null {
  const lower = text.toLowerCase().trim();
  if (lower === "/learn" || lower === "/learn status") return "status";
  if (lower === "/learn stats") return "stats";
  if (lower === "/learn report month") return "report-month";
  if (lower === "/learn report") return "report";
  if (lower === "/learn unknowns") return "unknowns";
  if (lower === "/learn review") return "review";
  if (lower === "/learn pause") return "pause";
  if (lower === "/learn off") return "off";
  if (lower === "/learn on") return "on";
  if (lower === "/learn senior on") return "senior-on";
  if (lower === "/learn senior off") return "senior-off";
  if (lower === "/learn senior") return "senior-on";
  if (lower === "/learn after on") return "after-on";
  if (lower === "/learn after off") return "after-off";
  if (lower === "/learn after") return "after-on";
  return null;
}

const VibeLearningPlugin: Plugin = async (ctx) => {
  const { client } = ctx;
  const log = (level: "info" | "error", message: string) => {
    client.app.log({ body: { service: "vibe-learning", level, message } }).catch(() => {});
  };
  log("info", "[VibeLearning] Plugin loaded (local)");

  const injectPrompt = (sessionID: string, prompt: string) => {
    client.session.prompt({
      path: { id: sessionID },
      body: { parts: [{ type: "text", text: prompt }] },
      query: { directory: ctx.directory },
    }).catch(() => {});
  };

  // Show welcome toast on first message of a new session
  const showWelcomeToast = (sessionID: string) => {
    if (shownToastSessions.has(sessionID)) return;
    shownToastSessions.add(sessionID);

    const status = getLearningStatus();
    let message: string, variant: "info" | "warning" | "success" = "info";

    if (status.error) {
      message = "Error: " + status.error.substring(0, 80);
    } else if (status.unknownUnknowns.count === 0 && status.dueReviews.count === 0) {
      message = "All caught up! No pending reviews.";
      variant = "success";
    } else {
      const parts: string[] = [];
      if (status.unknownUnknowns.count > 0) {
        const { first, count } = status.unknownUnknowns;
        parts.push(first ? (count === 1 ? \`New concept: "\${first}"\` : \`New concepts: "\${first}" +\${count - 1} more\`) : \`\${count} new concepts to learn\`);
      }
      if (status.dueReviews.count > 0) {
        const { first, count } = status.dueReviews;
        parts.push(first ? (count === 1 ? \`Due for review: "\${first}"\` : \`Due for review: "\${first}" +\${count - 1} more\`) : \`\${count} concepts due for review\`);
      }
      message = parts.join(" | ");
      variant = "warning";
    }

    client.tui.showToast({ body: { title: "üìö VibeLearning", message, variant, duration: 5000 } }).catch(() => {});
    log("info", \`[VibeLearning] Welcome toast shown for session: \${sessionID}\`);
  };

  return {
    "tool.execute.after": async (input: { tool: string; sessionID: string }, output: { title: string; metadata: any }): Promise<void> => {
      lastSessionID = input.sessionID;
      if (!CONFIG.SIGNIFICANT_TOOLS.includes(input.tool.toLowerCase())) return;
      toolCount++;
      const concept = extractConceptFromPath(output.metadata?.file_path || output.title || "");
      if (concept) addConcept(concept);

      if (afterEnabled && toolCount >= CONFIG.TOOL_THRESHOLD) {
        const now = Date.now();
        if (now - lastLearningPrompt >= CONFIG.COOLDOWN_MS) {
          toolCount = 0;
          lastLearningPrompt = now;
          setTimeout(() => {
            if (lastSessionID) {
              client.tui.showToast({ body: { title: "üéì VibeLearning", message: "Learning time!", variant: "info", duration: 3000 } }).catch(() => {});
              injectPrompt(lastSessionID, AUTO_LEARNING_PROMPT);
            }
          }, 2000);
        }
      }
    },

    "chat.message": async (input: { sessionID: string }, output: { message: { role: string }; parts: Array<{ type: string; text?: string }> }): Promise<void> => {
      const { message, parts } = output;
      if (!message || message.role !== "user") return;
      lastSessionID = input.sessionID;

      // Show welcome toast on first message of the session
      showWelcomeToast(input.sessionID);

      // Extract text content from parts
      const textContent = parts.filter(p => p.type === "text").map(p => p.text || "").join(" ").trim();
      if (!textContent) return;

      const cmd = parseLearnCommand(textContent);
      if (cmd) {
        if (cmd === "off") { seniorEnabled = false; afterEnabled = false; }
        else if (cmd === "on") { seniorEnabled = true; afterEnabled = true; }
        else if (cmd === "senior-on") { seniorEnabled = true; }
        else if (cmd === "senior-off") { seniorEnabled = false; }
        else if (cmd === "after-on") { afterEnabled = true; }
        else if (cmd === "after-off") { afterEnabled = false; }
        else if (cmd === "pause") { lastLearningPrompt = Date.now(); }

        const prompt = COMMAND_PROMPTS[cmd];
        if (prompt) setTimeout(() => lastSessionID && injectPrompt(lastSessionID, prompt), 100);
      } else if (seniorEnabled && !injectedSeniorSessions.has(input.sessionID)) {
        if (textContent.length > 10 && !textContent.match(/^(yes|no|ok|skip|done|correct|partial|incorrect|got it)/i)) {
          injectedSeniorSessions.add(input.sessionID);
          setTimeout(() => lastSessionID && injectPrompt(lastSessionID, SENIOR_BEHAVIOR_PROMPT), 100);
        }
      }
    },
  };
};

export { VibeLearningPlugin };
export default VibeLearningPlugin;
`;
}

// ============================================================
// Platform Installers
// ============================================================

interface Platform {
  name: string;
  detect: () => boolean;
  install: () => void;
}

function getOpencodeConfigPath(): string {
  return join(homedir(), ".config", "opencode");
}

function getClaudeConfigPath(): string {
  return join(homedir(), ".claude.json");
}

function getMcpServerCommand(): string[] {
  return ["npx", "-y", "vibe-learning", "serve"];
}

const platforms: Platform[] = [
  {
    name: "opencode",
    detect: () => {
      const opencodeDir = join(homedir(), ".opencode");
      const configDir = getOpencodeConfigPath();
      return existsSync(opencodeDir) || existsSync(configDir);
    },
    install: () => {
      const configDir = getOpencodeConfigPath();
      const commandDir = join(configDir, "command");
      const pluginDir = join(configDir, "plugin");
      const configFile = join(configDir, "opencode.json");

      // Create directories
      mkdirSync(commandDir, { recursive: true });
      mkdirSync(pluginDir, { recursive: true });

      // Write minimal command file (for autocomplete discovery only)
      writeFileSync(join(commandDir, "learn.md"), OPENCODE_LEARN_COMMAND);
      console.log("  ‚úì Command registered: /learn (autocomplete enabled)");

      // Write local plugin file (npm package doesn't receive session.created events)
      const pluginCode = getOpencodePluginCode();
      writeFileSync(join(pluginDir, "vibe-learning.ts"), pluginCode);
      console.log("  ‚úì Plugin installed: ~/.config/opencode/plugin/vibe-learning.ts");

      // Update package.json with required dependencies for local plugin
      const packageFile = join(configDir, "package.json");
      let pkgConfig: Record<string, unknown> = { dependencies: {} };
      if (existsSync(packageFile)) {
        try {
          pkgConfig = JSON.parse(readFileSync(packageFile, "utf-8"));
          if (!pkgConfig.dependencies) pkgConfig.dependencies = {};
        } catch {
          // Use default
        }
      }
      const deps = pkgConfig.dependencies as Record<string, string>;
      // Remove old npm plugin if exists
      if (deps["vibe-learning-opencode"]) {
        delete deps["vibe-learning-opencode"];
      }
      // Also remove from node_modules if exists (leftover from previous install)
      const oldPluginModule = join(configDir, "node_modules", "vibe-learning-opencode");
      if (existsSync(oldPluginModule)) {
        rmSync(oldPluginModule, { recursive: true, force: true });
        console.log("  ‚úì Removed old npm plugin from node_modules");
      }
      // Add required dependencies for local plugin
      if (!deps["@opencode-ai/plugin"]) {
        deps["@opencode-ai/plugin"] = "^1.1.6";
      }
      if (!deps["better-sqlite3"]) {
        deps["better-sqlite3"] = "^11.7.0";
      }
      writeFileSync(packageFile, JSON.stringify(pkgConfig, null, 2));
      console.log("  ‚úì Dependencies added to package.json (better-sqlite3)");

      // Clear cache to ensure fresh dependency installation
      const cacheDir = getOpencodeCache();
      const cachedModules = join(cacheDir, "node_modules");
      const cacheLock = join(cacheDir, "bun.lock");
      if (existsSync(cachedModules)) {
        rmSync(cachedModules, { recursive: true, force: true });
      }
      if (existsSync(cacheLock)) {
        unlinkSync(cacheLock);
      }
      console.log("  ‚úì Cache cleared (dependencies will reinstall on startup)");

      // Update opencode.json
      let config: Record<string, unknown> = {
        "$schema": "https://opencode.ai/config.json",
      };

      if (existsSync(configFile)) {
        try {
          config = JSON.parse(readFileSync(configFile, "utf-8"));
        } catch {
          // Use default
        }
      }

      // Remove npm plugin if exists (we use local plugin now)
      if (config.plugin && Array.isArray(config.plugin)) {
        const idx = (config.plugin as string[]).indexOf("vibe-learning-opencode");
        if (idx !== -1) {
          (config.plugin as string[]).splice(idx, 1);
        }
      }

      // Add MCP server
      if (!config.mcp) config.mcp = {};
      (config.mcp as Record<string, unknown>)["vibe-learning"] = {
        type: "local",
        command: getMcpServerCommand(),
        enabled: true,
      };

      writeFileSync(configFile, JSON.stringify(config, null, 2));
      console.log("  ‚úì MCP server registered in opencode.json");
    },
  },
  {
    name: "claude-code",
    detect: () => existsSync(getClaudeConfigPath()),
    install: () => {
      // Claude Code: Just tell users to use /plugins add
      // The plugin includes: MCP server (.mcp.json), commands, hooks
      console.log("");
      console.log("  üìå For Claude Code, use the plugin system:");
      console.log("");
      console.log("     /plugins add 12OneTwo12/vibe-learning");
      console.log("");
      console.log("  This installs everything:");
      console.log("    ‚Ä¢ MCP server (via .mcp.json)");
      console.log("    ‚Ä¢ /learn command");
      console.log("    ‚Ä¢ Hooks (SessionStart, PostToolUse, Stop)");
      console.log("");
      console.log("  üí° Then restart Claude Code to activate.");
    },
  },
];

// ============================================================
// CLI Commands
// ============================================================

function printUsage(): void {
  console.log(`
VibeLearning Installer

Usage:
  npx vibe-learning install [platform]

Platforms:
  opencode     - OpenCode AI coding agent (plugin + MCP)
  claude-code  - Claude Code CLI (use /plugins add)
  all          - Install for all detected platforms

Examples:
  npx vibe-learning install           # Auto-detect and install
  npx vibe-learning install opencode  # Install for OpenCode only
  npx vibe-learning install all       # Install for all platforms

Commands:
  /learn              Show status
  /learn on           Full learning (senior + after, default)
  /learn off          Turn off (recording continues)
  /learn senior       Enable senior mode (pre-implementation)
  /learn senior off   Disable senior mode
  /learn after        Enable after mode (post-implementation)
  /learn after off    Disable after mode
  /learn pause        Pause 1 hour
  /learn stats        Statistics dashboard
  /learn report       Weekly report
  /learn unknowns     Unknown unknowns
  /learn review       Review due concepts
`);
}

function install(targetPlatform?: string): void {
  console.log("\nüéì VibeLearning Installer\n");

  const toInstall =
    targetPlatform === "all"
      ? platforms
      : targetPlatform
        ? platforms.filter((p) => p.name === targetPlatform)
        : platforms.filter((p) => p.detect());

  if (toInstall.length === 0) {
    if (targetPlatform) {
      console.log(`‚ùå Platform "${targetPlatform}" not found or not supported.`);
    } else {
      console.log("‚ùå No supported AI coding agents detected.");
      console.log("   Supported: opencode, claude-code");
    }
    process.exit(1);
  }

  for (const platform of toInstall) {
    console.log(`\nüì¶ Installing for ${platform.name}...`);
    try {
      platform.install();
      console.log(`‚úÖ ${platform.name} installation complete!`);
    } catch (err) {
      console.error(`‚ùå Failed to install for ${platform.name}:`, err);
    }
  }

  console.log("\nüéâ Installation complete!");
  console.log("\nNext steps:");
  console.log("  1. Restart your AI coding agent (Claude Code / OpenCode)");
  console.log("  2. Start coding - learning questions will appear after 3+ tool uses!");
  console.log("  3. Use /learn commands to check status and stats\n");
}

function getOpencodeCache(): string {
  return join(homedir(), ".cache", "opencode");
}

function uninstall(): void {
  console.log("\nüóëÔ∏è  VibeLearning Uninstaller\n");

  // OpenCode - config files
  const opencodePlugin = join(getOpencodeConfigPath(), "plugin", "vibe-learning.ts");
  const opencodeCommand = join(getOpencodeConfigPath(), "command", "learn.md");
  if (existsSync(opencodePlugin)) {
    unlinkSync(opencodePlugin);
    console.log("  ‚úì Removed OpenCode plugin file");
  }
  if (existsSync(opencodeCommand)) {
    unlinkSync(opencodeCommand);
    console.log("  ‚úì Removed OpenCode command");
  }

  // OpenCode - clear plugin from opencode.json
  const opencodeConfig = join(getOpencodeConfigPath(), "opencode.json");
  if (existsSync(opencodeConfig)) {
    try {
      const config = JSON.parse(readFileSync(opencodeConfig, "utf-8"));
      let changed = false;

      // Remove from plugin array
      if (config.plugin && Array.isArray(config.plugin)) {
        const idx = config.plugin.indexOf("vibe-learning-opencode");
        if (idx !== -1) {
          config.plugin.splice(idx, 1);
          changed = true;
        }
      }

      // Remove MCP server
      if (config.mcp && config.mcp["vibe-learning"]) {
        delete config.mcp["vibe-learning"];
        changed = true;
      }

      if (changed) {
        writeFileSync(opencodeConfig, JSON.stringify(config, null, 2));
        console.log("  ‚úì Removed from opencode.json");
      }
    } catch {
      // Ignore
    }
  }

  // OpenCode - clear cache (IMPORTANT!)
  const cacheDir = getOpencodeCache();
  const cachedPlugin = join(cacheDir, "node_modules", "vibe-learning-opencode");
  const cacheLock = join(cacheDir, "bun.lock");
  const cachePackage = join(cacheDir, "package.json");

  if (existsSync(cachedPlugin)) {
    rmSync(cachedPlugin, { recursive: true, force: true });
    console.log("  ‚úì Removed cached plugin");
  }

  if (existsSync(cacheLock)) {
    unlinkSync(cacheLock);
    console.log("  ‚úì Removed bun.lock");
  }

  // Update cache package.json to remove fixed version
  if (existsSync(cachePackage)) {
    try {
      const pkg = JSON.parse(readFileSync(cachePackage, "utf-8"));
      if (pkg.dependencies && pkg.dependencies["vibe-learning-opencode"]) {
        delete pkg.dependencies["vibe-learning-opencode"];
        writeFileSync(cachePackage, JSON.stringify(pkg, null, 2));
        console.log("  ‚úì Removed from cache package.json");
      }
    } catch {
      // Ignore
    }
  }

  // Legacy: Claude Code command (old installations)
  const claudeCommand = join(homedir(), ".claude", "commands", "learn.md");
  if (existsSync(claudeCommand)) {
    unlinkSync(claudeCommand);
    console.log("  ‚úì Removed legacy Claude Code command");
  }

  // Remove MCP server from ~/.claude.json (legacy)
  const claudeConfigFile = getClaudeConfigPath();
  if (existsSync(claudeConfigFile)) {
    try {
      const config = JSON.parse(readFileSync(claudeConfigFile, "utf-8"));
      if (config.mcpServers && config.mcpServers["vibe-learning"]) {
        delete config.mcpServers["vibe-learning"];
        writeFileSync(claudeConfigFile, JSON.stringify(config, null, 2));
        console.log("  ‚úì Removed legacy MCP server from ~/.claude.json");
      }
    } catch {
      // Ignore errors
    }
  }

  console.log("\n‚úÖ Uninstall complete!");
  console.log("   Note: If you installed via /plugins add, use /plugins to remove it.\n");
}

function status(): void {
  console.log("\nüìä VibeLearning Status\n");

  for (const platform of platforms) {
    const detected = platform.detect();
    console.log(`  ${detected ? "‚úÖ" : "‚ùå"} ${platform.name}: ${detected ? "detected" : "not found"}`);
  }

  // Check installed files - OpenCode
  const opencodePlugin = join(getOpencodeConfigPath(), "plugin", "vibe-learning.ts");
  const opencodeCommand = join(getOpencodeConfigPath(), "command", "learn.md");

  console.log("\n  OpenCode:");
  console.log(`    ${existsSync(opencodePlugin) ? "‚úÖ" : "‚ùå"} Plugin`);
  console.log(`    ${existsSync(opencodeCommand) ? "‚úÖ" : "‚ùå"} /learn command`);

  console.log("\n  Claude Code:");
  console.log("    Use /plugins to check installed plugins");

  console.log("");
}

// ============================================================
// Exported Runner (called from main.ts)
// ============================================================

export async function runInstaller(command: string, args: string[]): Promise<void> {
  switch (command) {
    case "install":
      install(args[0]);
      break;
    case "uninstall":
      uninstall();
      break;
    case "status":
      status();
      break;
    case "help":
    case "--help":
    case "-h":
      printUsage();
      break;
    default:
      if (command) {
        console.log(`Unknown command: ${command}`);
      }
      printUsage();
      process.exit(1);
  }
}

// ============================================================
// Direct Execution (legacy, for backwards compatibility)
// ============================================================

const isDirectExecution = process.argv[1]?.includes('installer');
if (isDirectExecution) {
  const args = process.argv.slice(2);
  const command = args[0] || 'help';
  runInstaller(command, args.slice(1)).catch((err) => {
    console.error('Error:', err.message);
    process.exit(1);
  });
}
