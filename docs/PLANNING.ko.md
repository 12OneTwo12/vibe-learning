# VibeLearning MCP - 프로젝트 기획 문서

> **"바이브 코딩하면서 진짜 성장하기"**
> Claude Code, OpenCode 같은 AI 코딩 에이전트를 위한 학습 MCP 서버

---

## 목차

1. [문제 정의](#1-문제-정의)
2. [해결책](#2-해결책)
3. [타겟 사용자](#3-타겟-사용자)
4. [핵심 기능](#4-핵심-기능)
   - 4.1 즉각적 가치: 코드 인사이트
   - 4.2 점진적 깊이 시스템
   - 4.3 간격 반복 시스템 (SM-2)
   - 4.4 학습 분석
   - 4.5 면접 준비
   - 4.6 질문 전략 (피로도 관리)
   - 4.7 답변 평가 철학
   - 4.8 학습 리포트
   - 4.9 Unknown Unknowns 시각화
   - 4.10 시니어 모드 ← NEW
5. [사용 시나리오](#5-사용-시나리오)
6. [아키텍처](#6-아키텍처)
7. [기술 스택](#7-기술-스택)
8. [경쟁 분석](#8-경쟁-분석)
9. [로드맵](#9-로드맵)
10. [열린 질문들](#10-열린-질문들)

---

## 1. 문제 정의

### 핵심 문제

AI 코딩 도구로 생산성은 높아졌지만, 개발자의 실력 성장은 검증되지 않습니다.

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│   "AI 덕분에 생산성이 10배가 됐어..."                       │
│                                                              │
│   "...근데 나는 진짜 성장하고 있는 걸까?"                   │
│                                                              │
│   "면접에서 '왜 이렇게 했어요?' 물으면 답 못할 것 같아"     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 구체적 증상

| 상황 | 문제 |
|-----|------|
| 코드가 작동함 | 왜 작동하는지 설명 못함 |
| 같은 개념 5번째 구현 | 여전히 Level 1 이해도 |
| 면접 준비 | AI 없이 설명할 자신 없음 |
| 디버깅 | AI에게 의존, 직접 해결 능력 퇴화 불안 |

### 기존 도구의 한계

| 도구 | 하는 것 | 안 하는 것 |
|-----|--------|-----------|
| AI 코딩 (Copilot, Claude) | 코드 빠르게 생성 | 이해했는지 검증 |
| LLM에게 질문 | 물어보면 설명 | 능동적으로 확인, 추적 |
| 학습 플랫폼 (LeetCode) | 개념 교육 | 실무 코드와 연결 |
| 코드 리뷰 도구 | 코드 품질 체크 | 개발자 이해도 체크 |

**빈틈:** 코딩하면서 실제로 학습하고 있는지 확인해주는 도구가 없습니다.

---

## 2. 해결책

### VibeLearning: 바이브 코딩의 학습 완충제

VibeLearning은 바이브 코딩 중 학습을 **자동으로 트리거하고 추적**하는 MCP 서버입니다.

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│   AI 코딩 ←──── VibeLearning ────→ 진짜 학습               │
│   (빠름)        (완충제)             (성장)                 │
│                                                              │
│   속도 유지.     빈 틈 메우기.        실력 획득.            │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 핵심 가치

1. **능동적 학습** - 물어보지 않아도 먼저 확인
2. **깊이 추적** - 같은 개념도 레벨별로 다른 질문
3. **복습 최적화** - 망각 곡선 기반 스케줄링
4. **성장 측정** - 데이터 기반 숙련도 확인

### 왜 MCP 서버가 필요한가?

**핵심 문제:** Claude는 세션 간 기억이 없습니다.

```
┌─────────────────────────────────────────────────────────────┐
│                   Claude의 근본적 한계                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  세션 1: "Cache-Aside 패턴 배웠어요"                        │
│  세션 2: "저번에 뭐 배웠더라?" → Claude: "모릅니다"         │
│                                                              │
│  세션 5: "내가 캐싱 잘 알아?" → Claude: "잘하시는 것 같아요"│
│          (실제 데이터 없이 추측)                            │
│                                                              │
│  세션 10: "복습할 거 있어?" → Claude: "뭘 복습해야 할지..."│
│           (기록이 없어서 모름)                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

프롬프트나 CLAUDE.md로는 이 문제를 해결할 수 없습니다:

| 기능 | Claude 단독 | VibeLearning MCP |
|-----|------------|------------------|
| 질문하기 | ✅ 가능 | ✅ |
| **3주 전 학습 기록 조회** | ❌ 기억 없음 | ✅ SQLite |
| **"복습할 때 됐어요" 리마인드** | ❌ 불가능 | ✅ SM-2 스케줄링 |
| **"캐싱 78%" 숙련도 제공** | ❌ 추측만 가능 | ✅ 실제 데이터 |
| **"JWT 나올 때마다 스킵함" 패턴 분석** | ❌ 데이터 없음 | ✅ 기록 분석 |
| **"+23% 성장" 장기 추세** | ❌ 환각 위험 | ✅ SQL 쿼리 |

**MCP가 제공하는 것:**

```
1. 영속적 기억 (SQLite)
   └─ "2주 전에 Cache-Aside 배웠고, Level 2까지 감"

2. 복습 리마인드 (SM-2)
   └─ "JWT 복습 주기 도래. 오늘 물어볼까요?"

3. 숙련도 데이터
   └─ "캐싱 78%, 인증 52%, DB 89%"

4. 패턴 분석
   └─ "Kubernetes 나오면 항상 스킵하시네요"

5. 성장 증거
   └─ "3개월간 평균 레벨 1.8 → 2.6"
```

**핵심:** VibeLearning은 단순한 "질문 프롬프트"가 아니라, **세션을 넘어 학습을 기억하고, 복습을 리마인드하고, 성장을 증명하는** MCP 도구입니다.

### 가치 전달 타임라인

| 시점 | 느끼는 가치 |
|-----|-----------|
| **즉시** | 코드 인사이트 - "아 이런 게 있구나" |
| **첫 세션** | 잠재적 문제 감지 - "이거 몰랐는데" |
| **첫 주** | 주간 리포트 - "이번 주 이런 거 다뤘구나" |
| **첫 달** | 성장 대시보드 + 약점 분석 - "나 인증 쪽이 약하네" |
| **3개월** | 깊이 레벨 상승 + 면접 준비 - "시니어 수준 됐다" |

**Off 모드 사용자도 가치 느끼는 시점:**

```
첫 주: /learn report → "질문 안 받았는데도 정리해주네"
       → 진입 장벽 낮게 유지하면서 가치 전달
```

### 모드와 기능 분리

**모드** = 언제 질문하나 (질문 타이밍)
**기능** = 언제든 사용 가능 (명령어로 호출)

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│  모드 (질문 타이밍)              기능 (언제든 호출)         │
│  ─────────────────────          ─────────────────────────   │
│  • After  - 작업 완료 후         • /learn report  - 리포트  │
│  • Before - 작업 시작 전         • /learn stats   - 통계    │
│  • Off    - 질문 안 함           • /learn review  - 복습    │
│                                  • /learn interview - 면접  │
│                                                              │
│  ⚠️ 핵심: 모든 모드에서 기록은 계속됨                       │
│     → Off 모드여도 데이터 쌓임                              │
│     → 언제든 리포트 생성 가능                               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 네 가지 모드

| 모드 | 언제 | 동작 | 핵심 특징 |
|------|------|------|----------|
| **After** (기본) | 평소 작업 | 작업 완료 요약 후 질문 | 자연스러운 마무리 |
| **Before** | 새 기술 배울 때 | 구현 전 이해도 확인 | 스킵 가능, 절대 블로킹 안 함 |
| **Off** | 급한 마감 | 기록만, 질문 없음 | 방해 없음, 리포트는 가능 |
| **Senior** ← NEW | 실력 키우고 싶을 때 | 반론 제시, 설득해야 진행 | 깊은 학습, 시니어 마인드셋 |

### 트리거 방식: 작업 요약 기반

AI Agent는 작업 완료 시 요약을 생성합니다. 이 요약에서 핵심 개념을 추출해 질문합니다:

```
┌─────────────────────────────────────────────────────────────┐
│              작업 요약 기반 트리거                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 개발자: "Redis 캐싱 구현해줘"                           │
│                                                              │
│  2. Claude: [작업 수행]                                     │
│     - src/services/user.ts 수정                             │
│     - src/cache/redis.ts 생성                               │
│     - tests/cache.test.ts 추가                              │
│                                                              │
│  3. Claude: "완료했습니다!                                  │
│                                                              │
│     📋 작업 요약:                                           │
│     • UserService에 Redis 캐싱 추가                         │
│     • Cache-Aside 패턴 적용                                 │
│     • TTL 1시간 설정                                        │
│                                                              │
│     💡 혹시 Cache-Aside 패턴이 뭔지 아세요?"               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**왜 작업 요약 후인가:**

| 코드 생성마다 질문 | 작업 요약 후 질문 |
|------------------|------------------|
| 흐름 방해 | 자연스러운 마무리 |
| 코드 분석 필요 | 요약에 개념 이미 있음 |
| 빈번한 트리거 | 적절한 빈도 |

---

## 3. 타겟 사용자

### 핵심 타겟: 귀찮더라도 진짜 성장하고 싶은 개발자

```
"AI 덕분에 빠르게 만들긴 하는데... 나 진짜 성장하고 있나?"
"면접에서 '왜 이렇게 했어요?' 물으면 답 못할 것 같아"
"불안한 거 알아. 그래서 뭔가 하고 싶어."
```

- 바이브 코딩이 편하지만 진심으로 불안함
- Anki 같은 도구 시도해봤지만 코딩과 분리되어 포기한 경험
- 별도 학습 시간은 없지만, 작업 끝나고 질문 1-2개는 감수할 의지 있음

### 구체적 페르소나

| 페르소나 | 핵심 동기 |
|----------|----------|
| **성장 원하는 주니어** (1-3년) | "시니어 되고 싶은데 AI만 쓰면 평생 주니어일 것 같아" |
| **면접 준비 개발자** | "왜 이렇게 했어요?"에 답하는 연습 필요 |
| **자기개발 의지 있는 시니어** (5년+) | AI 의존도 높아지는 게 불안, 감 유지하고 싶음 |

### 타겟이 아닌 사람

- 바이브 코딩에 만족하는 개발자 → 질문 자체가 짜증
- **불안하지만 행동 안 하는 개발자** → Off만 쓰다 삭제 (이 사람을 위해 기능 희석 안 함)

---

## 4. 핵심 기능

### 4.1 즉각적 가치: 코드 인사이트

질문 전에 먼저 가치를 제공합니다:

```
개발자: "유저 API에 Redis 캐싱 구현해줘"

Claude: [캐싱 코드 생성]

"완료! Cache-Aside 패턴으로 Redis 캐싱을 구현했어요.

💡 이 코드에서 알아두면 좋은 것:
• Cache-Aside 패턴 사용 (가장 일반적인 방식)
• TTL 1시간 = 일반적인 선택, 데이터 특성에 따라 조정 가능
• 주의: 트래픽 높으면 Cache Stampede 가능성 있음

궁금한 거 있으면 물어보세요!"
```

**왜 중요한가:**
- 질문 안 해도 즉시 가치 제공
- 사용자가 "이 도구 유용하네" 느끼는 첫 순간
- 학습 부담 없이 정보 획득

### 4.2 점진적 깊이 시스템

같은 개념도 숙련도에 따라 다른 질문을 합니다:

```
┌─────────────────────────────────────────────────────────────┐
│              점진적 깊이 레벨                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Level 1 - 인식                                              │
│  "여기 어떤 캐싱 패턴을 썼나요?"                            │
│  → "Cache-Aside요"                                          │
│                                                              │
│  Level 2 - 이해                                              │
│  "Cache-Aside가 어떻게 작동하는지 설명해주실 수 있어요?"    │
│  → 캐시 확인 → miss → DB 조회 → 캐시에 저장                │
│                                                              │
│  Level 3 - 비교/트레이드오프                                 │
│  "언제 Write-Through를 대신 쓰나요?"                        │
│  → 일관성 vs 지연시간, write-heavy 워크로드                 │
│                                                              │
│  Level 4 - 엣지 케이스                                       │
│  "Cache Stampede가 뭐고 어떻게 방지하나요?"                 │
│  → Thundering herd, mutex 락, early refresh                 │
│                                                              │
│  Level 5 - 아키텍처                                          │
│  "1천만 유저 소셜 피드용 캐싱 설계해보세요"                 │
│  → 다중 레이어, CDN, hot/cold 분리, 무효화 전략             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**작동 방식:**

```
세션 1: 캐싱 처음 접함
Claude: "어떤 패턴 썼는지 아세요?" (Level 1)
→ 기록됨: 캐싱 Level 1 ✓

세션 5: 캐싱 4번 다룬 상태
Claude: "Cache-Aside는 아시니까, Cache Stampede는 뭔가요?" (Level 4)
→ 히스토리 기반으로 레벨 상승
```

### 4.3 간격 반복 시스템 (SM-2)

배운 것을 잊기 전에 복습 시점을 알려줍니다:

```
┌─────────────────────────────────────────────────────────────┐
│              에빙하우스 망각 곡선                            │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  기억                                                        │
│  유지율                                                      │
│     │                                                        │
│ 100%├─●                                                      │
│     │  ╲        복습 1       복습 2       복습 3            │
│  80%│   ╲          ●             ●             ●            │
│     │    ╲        ╱ ╲           ╱ ╲           ╱ ╲           │
│  60%│     ╲      ╱   ╲         ╱   ╲         ╱   ╲          │
│     │      ╲    ╱     ╲       ╱     ╲       ╱     ╲         │
│  40%│       ╲  ╱       ╲     ╱       ╲     ╱       ╲        │
│     │        ●──────────●───────────●───────────●           │
│  20%│     복습 없이: 빠른 망각                               │
│     │                                                        │
│     └─────┬─────┬─────┬─────┬─────┬─────┬───── 시간        │
│         1일  3일   7일   14일   30일  60일                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**작동 방식:**

```
정답 → 복습 간격 늘림 (1일 → 3일 → 7일 → 14일 → 30일...)
오답 → 간격 리셋, 더 쉬운 형태로 재시도

Day 1:  JWT 인증 학습 → 다음 복습: Day 2
Day 2:  복습 (맞춤) → 다음 복습: Day 5
Day 5:  복습 (맞춤) → 다음 복습: Day 12
Day 12: 복습 (헤맴) → 다음 복습: Day 14 (단축됨)
```

### 4.4 학습 분석

```
/stats 실행 시:

┌─────────────────────────────────────────────────────────────┐
│                    학습 현황                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  최근 30일 요약                                              │
│  ───────────────────────────────────────────────────────    │
│  다룬 개념: 42개                                             │
│  평균 깊이: Level 2.6                                        │
│  정답률: 73%                                                 │
│                                                              │
│  영역별 숙련도                                               │
│  ───────────────────────────────────────────────────────    │
│  캐싱         ████████████░░░░  78%  L3                      │
│  인증         ████████░░░░░░░░  52%  L2  ← 보강 추천        │
│  데이터베이스 ██████████████░░  89%  L4                      │
│  API 설계     ██████████░░░░░░  67%  L3                      │
│                                                              │
│  💡 인증 영역이 3주째 정체 중이에요.                        │
│     다음에 JWT 나오면 집중 학습 추천드려요.                 │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 4.5 면접 준비

```
/interview 실행 시:

Claude: "코드 히스토리 기반으로 연습해볼까요?

기술 영역:
• 인증 (JWT, refresh token) - 7회 구현, 85% 숙련도
• 캐싱 (Redis) - 5회 구현, 78% 숙련도
• Kubernetes - 4회 구현, 58% 숙련도 ← 약점

어떤 영역 연습할래요?"

개발자: "Kubernetes"

Claude: "좋은 선택이에요. 2주 전 deployment 기반:

'리소스 제한을 256Mi 메모리, 500m CPU로 설정했어요.
이 수치를 어떻게 정했는지 설명해주세요.
너무 낮으면 어떻게 돼요? 너무 높으면요?'"

개발자: [답변]

Claude: "좋은 포인트예요! 더 강하게 답변하려면:
• requests와 limits 차이 언급
• OOMKilled vs CPU throttling 구분
• 실제 모니터링 후 조정한다고 언급

면접관이 찾는 것: 'what'만 아니라 'why'와 트레이드오프"
```

### 4.6 질문 전략 (피로도 관리)

#### 핵심 리스크: 코딩 흐름 방해

```
┌─────────────────────────────────────────────────────────────┐
│                    가장 큰 우려                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  "바이브 코딩 중에 질문하면 흐름이 끊기지 않을까?"          │
│                                                              │
│  이건 진짜 리스크입니다.                                    │
│                                                              │
│  아무리 좋은 학습 도구여도,                                 │
│  짜증나면 → 끄고 → 학습 없음                               │
│                                                              │
│  VibeLearning이 실패하는 시나리오:                         │
│  코딩 몰입 중 → 질문 팝업 → "아 짜증나" → 삭제             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**설계 철학:** 의심스러우면 질문 안 함

```
놓친 학습 기회 < 사용자 이탈

한 번 꺼지면 다시 안 켜집니다.
차라리 질문을 덜 하는 게 낫습니다.
```

**현재 대응책:**

| 대응 | 효과 |
|-----|------|
| 15분 쿨다운 | 연속 질문 방지 |
| 연속 2회 스킵 → 1시간 자동 일시정지 | 바쁠 때 자동 감지 |
| "스킵" 한 마디면 즉시 종료 | 탈출 쉬움 |
| 작업 요약 후 질문 (코드 생성 중 아님) | 자연스러운 타이밍 |

**이게 충분한가?**

솔직히: **모릅니다. 써봐야 압니다.**

```
Phase 0 성공 기준:
- 직접 5회 사용
- 3회 이상 "유용했다"
- ✨ 짜증나지 않음 ← 이게 핵심
```

**추가로 고려 중인 것들:**

```
1. Flow 감지
   - 빠르게 연속으로 코드 생성 중이면 자동 스킵
   - "지금 몰입 중인 것 같네요" 감지

2. 질문 타이밍 조정
   - 현재: 작업 요약 후
   - 대안: 세션 종료 시 (흐름 방해 최소화)
   - 트레이드오프: 학습 맥락이 약해짐

3. 첫 설치 시 강도 선택
   - "적극적" / "보통" / "조용히" 모드
   - 사용자가 직접 선택
```

**핵심 원칙:** 이탈보다 나쁜 건 없다

---

**위험:** 질문이 너무 많으면 → 사용자가 꺼버림 → 학습 없음

#### 기본 설정 (Gentle)

```
┌─────────────────────────────────────────────────────────────┐
│              기본 질문 전략                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  쿨다운: 15분                                                │
│  스킵 2회 연속 → 1시간 자동 일시정지                        │
│  대상: 새 개념 또는 복습 필요 개념만                         │
│                                                              │
│  예시 세션 (1시간 코딩):                                     │
│  ├── 0:00  코드 생성 #1 (간단한 CRUD) → 질문 없음           │
│  ├── 0:10  코드 생성 #2 (JWT 구현) → 질문 #1               │
│  ├── 0:25  코드 생성 #3 (캐싱) → 쿨다운 중, 스킵           │
│  ├── 0:40  코드 생성 #4 (Rate Limiting) → 질문 #2          │
│  └── 0:55  코드 생성 #5 (리팩토링) → 질문 #3               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 질문 선택 우선순위

```
1순위: 처음 보는 개념 (새로운 학습 기회)
2순위: Level 1-2인 개념 (기초 다지기)
3순위: 복습 주기 도래 (SM-2 스케줄)
4순위: 이전에 틀린 개념 (보강 필요)

제외:
- Level 4-5 개념 (이미 숙달)
- 같은 세션에서 이미 질문한 개념
- 사소한 변경 (오타 수정, 포매팅)
```

#### 피로도 감지 → 자동 대응

```
┌─────────────────────────────────────────────────────────────┐
│              적응형 질문 빈도                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  신호                          → 대응                       │
│  ─────────────────────────────────────────────────────────  │
│  연속 2회 스킵                 → 1시간 자동 일시정지        │
│  "바빠요" 키워드               → 24시간 일시정지            │
│  일주일 참여율 < 30%           → 빈도 자동 감소             │
│                                                              │
│  핵심 원칙: 의심스러우면 질문 안 함                         │
│  → 놓친 학습 기회보다 사용자 이탈이 더 나쁨                 │
│                                                              │
│  MCP가 추적하는 것:                                         │
│  • consecutive_skips (연속 스킵 횟수)                       │
│  • last_question_at (마지막 질문 시간)                      │
│  • paused_until (일시정지 종료 시간)                        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 사용자 제어

```
/learn pause      → 1시간 일시 정지
/learn off        → 다시 켤 때까지 비활성화
/learn light      → 최소 질문
/learn focus auth → 인증 관련만 질문
```

#### "탈출구" 설계

모든 질문에 쉬운 opt-out:

```
Claude: "방금 사용한 캐싱 패턴에 대해 질문 하나..."

개발자: "스킵" (또는 그냥 무시)

Claude: "문제없어요! 나중에 얘기하고 싶으면 말씀하세요."
        → 페널티 없음, 죄책감 없음, 스킵으로 기록
```

### 4.7 답변 평가 철학

```
┌─────────────────────────────────────────────────────────────┐
│                   평가 원칙                                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 의심의 이익                                              │
│     • 이해를 보여주면 correct로 판정                        │
│     • 불완전한 용어 사용 페널티 안 줌                       │
│     • "거의 맞음"은 incorrect 아닌 partial                  │
│                                                              │
│  2. 테스트가 아닌 학습에 집중                                │
│     • 틀린 답 → 가르치는 기회                               │
│     • 절대 사용자를 바보처럼 느끼게 하지 않음               │
│     • 맞은 답은 진심으로 칭찬                               │
│                                                              │
│  3. 투명한 채점                                              │
│     • "왜 partial이에요?" 물으면 설명 가능                  │
│     • 예상 핵심 포인트 보여줌                               │
│     • 더 논의 제안                                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**평가 예시:**

```
질문: "여기 어떤 캐싱 패턴을 썼나요?"
핵심 포인트: ["Cache-Aside", "Lazy Loading", "캐시 먼저 확인"]

답변: "Cache-Aside - 캐시 확인하고, miss면 DB에서 가져와요"
→ 결과: correct (패턴명 + 동작 설명)

답변: "캐싱하는 거요"
→ 결과: partial (캐싱인 건 알지만, 패턴 특정 못함)

답변: "Write-Through 패턴이요"
→ 결과: incorrect (잘못된 패턴) → 설명 제공
```

### 4.8 학습 리포트

모든 모드에서 학습 기록이 쌓이므로, 언제든 리포트를 생성할 수 있습니다.

#### 리포트 명령어

```
/learn report           → 이번 주 리포트 (기본)
/learn report week      → 이번 주
/learn report month     → 이번 달
/learn report auth      → 인증 영역만
/learn report --save    → md 파일로 저장
```

#### 리포트 예시

```markdown
# 📊 학습 리포트 (2026년 1월 1주차)

## 이번 주 요약
- 다룬 개념: 12개 (신규 5개, 반복 7개)
- 질문 응답률: 75% (8/12 응답)
- 평균 레벨: 2.3 → 2.6 (+0.3)

---

## 🔴 보강 필요 영역

### 1. 인증 (Auth) - 4회 등장

**왜 보강 필요한가:**
- JWT refresh token 3번 구현, 매번 비슷한 질문
- "토큰 만료 처리" 부분에서 Claude 설명에 의존

**추천 학습:**
- [ ] JWT vs Session 차이점 정리
- [ ] Refresh Token Rotation 이해
- [ ] 토큰 탈취 대응 방안

**면접 예상 질문:**
> "JWT 토큰이 탈취되면 어떻게 대응하나요?"

---

### 2. 캐싱 (Caching) - 3회 등장

**관찰된 패턴:**
- Cache-Aside는 알고 있음 ✅
- Cache Stampede 언급 시 Claude 설명에 의존 ⚠️

**추천 학습:**
- [ ] Cache Stampede 방지 패턴 3가지
- [ ] TTL 설정 기준 (데이터 특성별)

---

## ✅ 잘하고 있는 영역

### 데이터베이스
- 인덱스 설계 이해도 높음 (Level 3)
- N+1 문제 인식하고 해결 가능

### API 설계
- REST 규칙 일관적
- 에러 핸들링 패턴 정착

---

## 💡 이번 주 Unknown Unknowns

> 이번 주에 접했지만 깊이 모르고 넘어간 개념들

1. **Connection Pooling** - DB 연결 코드에서 등장
2. **Rate Limiting 알고리즘** - Token Bucket vs Leaky Bucket
3. **CORS Preflight** - OPTIONS 요청이 먼저 가는 이유

---

## 📈 지난주 대비

| 영역 | 지난주 | 이번주 | 변화 |
|------|-------|-------|------|
| 인증 | 2회 | 4회 | 🔺 자주 다룸 |
| 캐싱 | 1회 | 3회 | 🔺 |
| K8s | 3회 | 0회 | - 안 다룸 |

---

*다음 리포트: 2026년 1월 13일 (월)*
```

#### Off 모드에서도 가치 제공

```
┌─────────────────────────────────────────────────────────────┐
│                    Off 모드 사용자 시나리오                  │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  월~목: 스프린트 중, Off 모드                               │
│        → 질문 없음, 방해 없음                               │
│        → 하지만 기록은 계속 쌓임                            │
│                                                              │
│  금요일: "/learn report"                                    │
│        → "이번 주 인증 쪽 많이 다뤘네요.                   │
│           JWT 복습 한번 해보시는 건 어때요?"               │
│                                                              │
│  가치: 코딩 흐름 전혀 방해 안 하면서도                     │
│        주간 단위로 학습 현황 파악 가능                      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 리포트가 제공하는 것

| 항목 | 설명 |
|------|------|
| **보강 필요 영역** | 반복 등장하는데 레벨이 안 오르는 개념 |
| **Unknown Unknowns** | 스쳐 지나갔지만 탐색 안 한 개념 |
| **면접 예상 질문** | 약점 영역 기반 질문 생성 |
| **성장 추이** | 전주/전월 대비 변화 |
| **학습 패턴** | 어떤 영역을 자주 다루는지 |

### 4.9 Unknown Unknowns 시각화

**핵심 가치:** "모르는 걸 모르는 것"을 발견하게 해줍니다.

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│   Known Unknowns          Unknown Unknowns                  │
│   (아는데 모르는 것)       (모르는 것도 모르는 것)           │
│   ┌─────────────────┐     ┌─────────────────────────┐       │
│   │                 │     │                          │       │
│   │  "JWT 뭐야?"    │     │  "Cache Stampede"를     │       │
│   │  → 물어볼 수    │     │  모르면 질문할 수       │       │
│   │    있음         │     │  조차 없음              │       │
│   │                 │     │                          │       │
│   └─────────────────┘     └─────────────────────────┘       │
│                                    ↑                         │
│                              VibeLearning이                  │
│                              이걸 잡아냄                     │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 작동 방식

```
1. 코드에서 개념 등장 감지
   → "Cache-Aside 패턴으로 구현했어요"
   → concept: cache-aside 기록

2. 관련 개념 자동 연결
   → cache-aside → [cache-stampede, write-through, ttl-strategy]
   → 이 중 탐색 안 한 것 추적

3. Unknown Unknowns 대시보드에 표시
   → "Cache Stampede: 관련 코드 3번 등장, 탐색 0회"
```

#### 대시보드 예시

```
/learn unknowns 실행 시:

┌─────────────────────────────────────────────────────────────┐
│              🔍 Unknown Unknowns 대시보드                   │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  이번 달 스쳐 지나간 개념들                                  │
│  ─────────────────────────────────────────────────────────  │
│                                                              │
│  🔴 높은 우선순위 (자주 등장, 전혀 탐색 안 함)              │
│  ├─ Cache Stampede     - 캐싱 코드 5회 등장, 탐색 0회       │
│  │   └─ "트래픽 많으면 DB 죽을 수 있어요"                  │
│  ├─ Connection Pooling - DB 코드 4회 등장, 탐색 0회         │
│  │   └─ "연결 관리 최적화 필요할 수 있어요"                │
│  └─ Token Rotation     - 인증 코드 3회 등장, 탐색 0회       │
│      └─ "보안 강화에 중요해요"                              │
│                                                              │
│  🟡 관심 가져볼 만한 것                                      │
│  ├─ Rate Limiting 알고리즘 (Token Bucket vs Leaky Bucket)   │
│  └─ CORS Preflight 동작 원리                                │
│                                                              │
│  ─────────────────────────────────────────────────────────  │
│  💡 "Cache Stampede 알아보기" [Enter]                       │
│  💡 "전체 목록 리포트로 저장" → /learn unknowns --save      │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 탐색 유도

```
사용자: "Cache Stampede 알아보기"

Claude: "Cache Stampede는 캐시가 만료되는 순간
수천 개 요청이 동시에 DB를 때리는 현상이에요.

방금 구현한 Redis 캐싱에서 발생할 수 있어요:
- TTL 만료 시 동시 요청 → DB 과부하

해결 방법:
• Mutex Lock: 하나의 요청만 캐시 재생성
• Early Refresh: 만료 전에 미리 갱신
• Jitter: TTL에 랜덤 값 추가

지금 당장은 괜찮지만, 트래픽 늘어나면 고려하세요.

이해됐으면 '확인', 더 알고 싶으면 '더 알려줘'라고 하세요."
```

**탐색 완료 시:**
```
→ cache-stampede: explored = true
→ Unknown Unknowns에서 제거
→ 학습 기록에 추가
```

#### 왜 중요한가

```
기존 방식:
  코드 작동함 → 넘어감 → Cache Stampede 모름 → 장애 나고 배움

VibeLearning:
  코드 작동함 → "관련해서 이런 게 있어요" → 미리 알게 됨

차이:
  장애 전에 vs 장애 후에 배우는가
```

### 4.10 시니어 모드

**핵심 가치:** 최대 3라운드까지 깊이 파고드는 "까다로운 시니어 개발자" 모드

```
┌─────────────────────────────────────────────────────────────┐
│                    Before vs Senior 핵심 차이               │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   Before 모드                      Senior 모드              │
│   ─────────────────────────       ─────────────────────     │
│                                                              │
│   "이거 뭔지 아세요?"              "왜 이거 선택했어요?"   │
│   → 1라운드 후 진행                → 최대 3라운드 푸시     │
│   → 틀려도 설명하고 바로 진행      → 더 깊이 파고들기      │
│                                    → 3라운드 후 진행        │
│                                                              │
│   느낌: 친절한 멘토                느낌: 까다로운 시니어    │
│   질문: "X가 뭐야?"                질문: "왜 X야? 근거는?" │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

#### 대상 사용자

```
- "진짜 시니어 되고 싶다"
- "AI한테 코드만 받지 말고 제대로 이해하고 싶다"
- "면접에서 '왜 이렇게 했어요?'에 막힘없이 답하고 싶다"
- "바이브 코딩하면서도 사고력 키우고 싶다"
```

#### 시니어 모드 동작 예시: 1라운드에 성공

```
개발자: "Redis 캐싱 구현해줘"

Claude: "[라운드 1/3] 🤔
Cache-Aside를 쓰려고 하는데, Write-Through 대신
이걸 선택한 이유가 뭐예요?"

─────────────────────────────────────────────────────────────

개발자: "읽기가 95%라서 Cache-Aside가 효율적이고,
       몇 초간의 stale data는 비즈니스적으로 허용 가능해요"

─────────────────────────────────────────────────────────────

Claude: "완벽한 근거예요! ✅ (1라운드 성공)

• 읽기/쓰기 비율 고려 ✓
• 비즈니스 요구사항 반영 ✓

이런 사고방식이 시니어예요. 바로 구현할게요!"

[코드 생성]
```

#### 시니어 모드 동작 예시: 3라운드까지 푸시

```
개발자: "JWT 인증 구현해줘"

Claude: "[라운드 1/3] 🤔
왜 세션 기반 대신 JWT를 선택했어요?"

─────────────────────────────────────────────────────────────

개발자: "요즘 다 JWT 쓰지 않나요?"

─────────────────────────────────────────────────────────────

Claude: "[라운드 2/3] 🤔
'다들 쓴다'는 근거가 아니에요.
JWT의 장단점을 생각해보면:
- 장점: stateless, 수평 확장 용이
- 단점: 토큰 무효화 어려움

이 프로젝트에서 JWT가 맞는 구체적인 이유가 있어요?"

─────────────────────────────────────────────────────────────

개발자: "음... 확장 때문에?"

─────────────────────────────────────────────────────────────

Claude: "[라운드 3/3] 🤔
가까워지고 있어요! 좀 더 구체적으로:
- 마이크로서비스 아키텍처인가요?
- 여러 서버에서 인증이 필요한가요?
- 세션 공유 스토리지(Redis) 운영이 부담인가요?"

─────────────────────────────────────────────────────────────

개발자: "잘 모르겠어요..."

─────────────────────────────────────────────────────────────

Claude: "괜찮아요! 📚 3라운드 동안 고민한 것 자체가 학습이에요.

정리해드릴게요:

**JWT가 맞는 경우:**
• 마이크로서비스 (서비스 간 인증)
• 수평 확장 필요 (세션 공유 비용 회피)
• 모바일 앱 (쿠키 대신 헤더)

**세션이 나은 경우:**
• 단일 서버
• 즉시 로그아웃 필요 (관리자 페이지)
• 토큰 탈취 리스크 최소화

이 프로젝트가 단일 서버 + 웹이면 세션도 좋은 선택이에요.
일단 JWT로 구현할게요!"

[코드 생성]

→ 기록: jwt 3라운드 후 설명 필요 ⚠️
```

#### 시니어 모드 vs 면접 준비

| 항목 | 시니어 모드 | 면접 준비 (/learn interview) |
|------|-----------|---------------------------|
| 시점 | 코딩 중 실시간 | 따로 시간 내서 |
| 목적 | 사고력 키우기 | 면접 연습 |
| 진행 | 설득 후 코드 생성 | 질문-답변 반복 |
| 피드백 | 즉시 | 종합 평가 |

#### 시니어 모드 설정

```
/learn senior        → 시니어 모드 활성화
/learn senior off    → 시니어 모드 비활성화
/learn senior light  → 가벼운 반론 (설득 안 해도 진행, 피드백만)
```

#### 기록되는 것

```
시니어 모드 기록 예시:
┌────────────────────┬────────┬─────────────────────┐
│ 개념               │ 라운드 │ 결과                │
├────────────────────┼────────┼─────────────────────┤
│ cache-aside        │ 1      │ ✅ 1라운드 성공     │
│ jwt                │ 3      │ ⚠️ 설명 필요        │
│ kubernetes-hpa     │ 2      │ ✅ 2라운드 성공     │
│ database-indexing  │ 3      │ ⚠️ 설명 필요        │
└────────────────────┴────────┴─────────────────────┘

→ 면접 대비 리포트:
  "jwt, database-indexing은 근거 설명 연습 필요"
```

#### 왜 "시니어" 모드인가

```
주니어: "이거 써요" → "왜요?" → "그냥 좋대요"
시니어: "이거 써요" → "왜요?" → "이 상황에서 A가 B보다 나은 이유는..."

시니어 모드는 두 번째 사고방식을 훈련합니다.
```

---

## 5. 사용 시나리오

### 시나리오 1: 자연스러운 대화형 학습 (After 모드)

```
개발자: "유저 API에 Redis 캐싱 구현해줘"

Claude: [캐싱 코드 생성]

"완료! Cache-Aside 패턴으로 Redis 캐싱을 구현했고,
TTL은 1시간으로 설정했어요.

그런데 혹시, 캐싱 전략에는 어떤 것들이 있고
제가 방금 사용한 방식이 뭔지 아세요?"

─────────────────────────────────────────────────────────────

개발자: "음... 캐시에 없으면 DB에서 가져와서 저장하는 거?"

─────────────────────────────────────────────────────────────

Claude: "맞아요! 그게 Cache-Aside 패턴 (Lazy Loading이라고도 해요).

다른 방식들도 있어요:

• Write-Through: 쓰기 시 캐시와 DB 동시 업데이트
  → 장점: 캐시 일관성 보장
  → 단점: 쓰기 느림

• Write-Behind: 캐시만 먼저 업데이트, DB는 나중에
  → 장점: 쓰기 빠름
  → 단점: 장애 시 데이터 유실 가능

한 가지 더 - Cache-Aside에서 'Cache Stampede'라는
문제가 생길 수 있는데, 혹시 들어보셨어요?"

─────────────────────────────────────────────────────────────

개발자: "아니요, 그게 뭔데요?"

─────────────────────────────────────────────────────────────

Claude: "캐시가 만료되는 순간 1000개 요청이 동시에 들어오면,
전부 DB를 때려요. DB 죽을 수 있어요.

해결 방법:
• Mutex Lock: 하나의 요청만 캐시 재생성
• Early Refresh: 만료 전에 미리 갱신

지금 당장은 괜찮지만, 트래픽 늘어나면 고려해보세요.
필요하면 구현 도와드릴게요!"
```

**포인트:** 퀴즈가 아니라 자연스러운 대화로 학습

### 시나리오 2: 바쁠 때 + 리포트 활용 (현실적 시나리오)

```
[월요일 - 스프린트 시작]
개발자: "/learn off"
VibeLearning: "학습 모드 Off. 기록은 계속됩니다."
→ 이번 주 내내 질문 없이 코딩

[월~목: Off 모드로 작업]
- 질문 없음, 방해 없음
- 하지만 어떤 개념이 등장했는지 기록 중:
  • JWT refresh token (3회)
  • Redis caching (2회)
  • Kubernetes deployment (1회)
  • Rate limiting (1회)

[금요일 점심]
개발자: "/learn report"

Claude: "📊 이번 주 학습 리포트

이번 주 요약:
- 다룬 개념: 7개
- 질문 응답: 0회 (Off 모드)

🔴 보강 추천:
• JWT refresh token - 3회 등장, 탐색 안 함
  → 토큰 갱신 전략 한번 정리해보시는 건 어때요?

💡 스쳐 지나간 것:
• Rate limiting - Token Bucket 알고리즘 사용했는데,
  Leaky Bucket과 차이 알고 계세요?

시간 되시면 /learn review로 복습해보세요!"

개발자: "주말에 볼게"
→ 리포트 md로 저장: /learn report --save
```

**핵심:**
- Off 모드여도 **기록은 계속** → 리포트 가능
- 코딩 흐름 **전혀 방해 안 함**
- 시간 날 때 리포트로 **비동기 학습**
- 스킵 = 실패 ❌, 스킵 = 지금은 아님 ✅

### 시나리오 3: 점진적 깊이 체험

**1주차:**
```
Claude: "어떤 패턴 썼는지 아세요?" (Level 1)
개발자: "Cache-Aside요"
→ Level 1 달성
```

**3주차:**
```
Claude: "Cache-Aside는 아시니까, 물어볼게요:
        언제 Write-Through를 대신 쓰나요?" (Level 3)
개발자: "쓰기는 느리지만 항상 일관성 있을 때?"
→ Level 3 달성
```

**6주차:**
```
Claude: "이 피드 초당 수천 요청 받을 수 있어요.
        캐시 만료되면 어떤 문제가 생겨요?" (Level 4)
개발자: "Cache Stampede요? mutex 락으로 방지?"
→ Level 4 달성
```

### 시나리오 4: Before 모드 (새 기술 학습)

```
개발자: [Before 모드 활성화]
개발자: "JWT 인증 구현해줘"

─────────────────────────────────────────────────────────────

Claude: "구현하기 전에, JWT에 대해 확인해볼게요.

JWT와 기존 세션 기반 인증의 핵심 차이가 뭘까요?

('그냥 구현해줘'라고 하시면 바로 넘어갈게요!)"

─────────────────────────────────────────────────────────────

개발자: "JWT는 stateless라서... 서버에서 세션 저장 안 해도 되나요?"

─────────────────────────────────────────────────────────────

Claude: "정확해요! 서버 측 세션 저장 없이도 되니까
수평 확장이 쉬워지는 게 핵심 장점이에요.

한 가지 트레이드오프가 있는데, 한번 발급하면 JWT를
쉽게 무효화할 수 없어요 (세션은 그냥 삭제하면 되지만).
그래서 refresh token과 token blacklist를 같이 구현할 거예요.

이제 인증 시스템 구현할게요."

[코드 생성]
```

**Before 모드 설계 철학:**
- 절대 블로킹 안 함
- "그냥 구현해줘" 하면 바로 진행
- 틀린 답 → 설명 먼저, 그래도 코드 생성
- 시험이 아니라 멘토가 시작 전에 확인해주는 느낌

---

## 6. 아키텍처

### 설계 원칙: LLM과 MCP의 역할 분리

**핵심 인사이트:** MCP 서버는 결정론적 계산에 집중하고, LLM(호스트)은 자연어 처리에 집중합니다.

```
┌─────────────────────────────────────────────────────────────┐
│                      역할 분리 원칙                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   호스트 (Claude)가 하는 것          MCP가 하는 것          │
│   ─────────────────────────          ──────────────────     │
│   • 코드 → 개념 추출                 • 학습 기록 저장       │
│   • 질문 생성 (템플릿 활용)          • SM-2 계산            │
│   • 자연어 답변 평가                 • 통계 쿼리            │
│   • 코드 인사이트 생성               • 복습 스케줄링        │
│   • 대화 흐름 관리                   • 피로도 판단          │
│                                      • 개념 레벨 추적       │
│                                                              │
│   ⚠️ 비결정론적, LLM 필요            ✅ 결정론적, 재현 가능  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**왜 이렇게 나누는가:**

| 작업 | LLM에게 맡기면 | MCP에게 맡기면 |
|------|---------------|---------------|
| "이 코드는 Cache-Aside다" | ✅ 문맥 이해 가능 | ❌ 패턴 매칭 한계 |
| "7일 후 복습" 계산 | ❌ 매번 다른 답 | ✅ 항상 같은 답 |
| "부분 정답" 판단 | ✅ 의미 이해 가능 | ❌ 키워드 매칭만 |
| "오늘 복습할 개념 5개" | ❌ DB 접근 불가 | ✅ SQL 쿼리 |

### 상위 수준 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                    AI 코딩 도구 (호스트)                     │
│         (Claude Code / Cursor / Windsurf)                   │
├─────────────────────────────────────────────────────────────┤
│  호스트의 책임:                                              │
│  • 코드 분석 → 개념 식별                                    │
│  • 질문 생성 (MCP에서 템플릿/레벨 참조)                     │
│  • 답변 평가 → 결과를 MCP에 기록                            │
│  • 사용자 대화 흐름 관리                                    │
└──────────────────────────┬──────────────────────────────────┘
                           │ MCP 프로토콜
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                 VibeLearning MCP Server                      │
├─────────────────────────────────────────────────────────────┤
│  MCP의 책임:                                                 │
│  • 결정론적 계산 (SM-2, 통계)                               │
│  • 데이터 저장/조회                                         │
│  • 피로도 기반 질문 여부 결정                               │
│  • 개념별 레벨/템플릿 제공                                  │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │    SM-2      │  │    피로도    │  │    통계      │       │
│  │   스케줄러   │  │    관리자    │  │   계산기     │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│                                                              │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │
│  │    개념      │  │    모드      │  │    기록      │       │
│  │  데이터베이스│  │    관리자    │  │   저장소     │       │
│  └──────────────┘  └──────────────┘  └──────────────┘       │
│                                                              │
└──────────────────────────┬──────────────────────────────────┘
                           │
                           ▼
┌─────────────────────────────────────────────────────────────┐
│                        SQLite                                │
│              ~/.vibe-learning/learning.db                    │
└─────────────────────────────────────────────────────────────┘
```

### MCP 도구 (단순화된 설계)

MCP는 **숫자 계산과 저장만** 담당합니다. 9개 핵심 도구:

| 도구 | 역할 |
|------|------|
| `should_ask_question` | 피로도 체크 |
| `get_concept_level` | 개념 레벨 조회 |
| `record_learning` | 학습 결과 기록 + SM-2 |
| `get_stats` | 학습 통계 (SQL GROUP BY) |
| `get_report_data` | 리포트 생성용 데이터 |
| `get_unknown_unknowns` | Unknown Unknowns 조회 ← NEW |
| `get_due_reviews` | 복습 필요 개념 |
| `get_mode` | 현재 모드 조회 |
| `set_mode` | 모드 설정 (Plugin에서 호출) |

```python
@mcp.tool()
async def should_ask_question() -> dict:
    """
    피로도 체크. 질문해도 되나?

    Returns:
        {
            "should_ask": true,
            "reason": "18m 30s since last question",
            "pending_reviews": 3,       -- 복습 필요한 개념 수
            "consecutive_skips": 0      -- 연속 스킵 횟수
        }

    should_ask=false인 경우:
        - consecutive_skips >= 2 → 1시간 자동 일시정지
        - 쿨다운 중 (마지막 질문 후 15분 미만)
        - 일시정지 중 (paused_until)
    """

@mcp.tool()
async def get_concept_level(concept_id: str) -> dict:
    """
    개념 레벨 조회. 없으면 자동 생성 (level=1).

    Args:
        concept_id: 호스트 LLM이 자유롭게 생성 (예: "cache-aside")
                    정규화: lowercase, 공백→하이픈

    Returns:
        {
            "concept_id": "cache-aside",
            "current_level": 2,
            "total_attempts": 5,
            "last_seen": "2026-01-05"
        }
    """

@mcp.tool()
async def record_learning(
    concept_id: str,
    level: int,
    result: Literal["correct", "partial", "incorrect", "skipped"]
) -> dict:
    """
    학습 결과 기록 + SM-2 계산.

    Returns:
        {
            "recorded": true,
            "new_level": 3,
            "next_review": "2026-01-13",
            "message": "Level 3 달성!"
        }
    """

@mcp.tool()
async def get_stats(period: str = "month") -> dict:
    """
    학습 통계 조회. SQL GROUP BY로 개념별 통계 계산.

    Args:
        period: "week", "month", "all"

    Returns:
        {
            "period": "month",
            "summary": {
                "total_concepts": 42,
                "total_attempts": 128,
                "correct_rate": 0.73,
                "avg_level": 2.6
            },
            "by_concept": [
                {
                    "concept_id": "cache-aside",
                    "current_level": 3,
                    "attempts": 5,
                    "correct_rate": 0.8,
                    "last_seen": "2026-01-05"
                },
                {
                    "concept_id": "jwt-auth",
                    "current_level": 2,
                    "attempts": 7,
                    "correct_rate": 0.52,
                    "last_seen": "2026-01-03"
                },
                ...
            ],
            "streak_days": 12
        }

    SQL 예시:
        SELECT concept_id,
               current_level,
               COUNT(*) as attempts,
               AVG(CASE WHEN result='correct' THEN 1.0 ELSE 0.0 END) as correct_rate
        FROM learning_records lr
        JOIN concept_progress cp ON lr.concept_id = cp.concept_id
        WHERE created_at > date('now', '-30 days')
        GROUP BY concept_id
        ORDER BY attempts DESC
    """

@mcp.tool()
async def get_report_data(
    period: str = "week",
    area: Optional[str] = None
) -> dict:
    """
    리포트 생성용 상세 데이터 조회.
    호스트 LLM이 이 데이터로 자연어 리포트 생성.

    Args:
        period: "week", "month", "all"
        area: 특정 영역만 (예: "auth", "caching")

    Returns:
        {
            "period": "2026-01-01 ~ 2026-01-07",
            "summary": {
                "concepts_touched": 12,
                "new_concepts": 5,
                "repeated_concepts": 7,
                "questions_asked": 10,
                "questions_answered": 8,
                "skip_rate": 0.2,
                "avg_level_start": 2.3,
                "avg_level_end": 2.6
            },
            "weak_areas": [
                {
                    "area": "auth",
                    "concepts": ["jwt-refresh", "token-rotation"],
                    "appearances": 4,
                    "avg_level": 1.5,
                    "signals": [
                        "3회 반복 등장, 레벨 변화 없음",
                        "skip 2회"
                    ]
                }
            ],
            "strong_areas": [
                {
                    "area": "database",
                    "concepts": ["indexing", "n-plus-one"],
                    "avg_level": 3.5,
                    "correct_rate": 0.9
                }
            ],
            "unknown_unknowns": [
                {
                    "concept_id": "connection-pooling",
                    "context": "DB 연결 코드에서 등장",
                    "first_seen": "2026-01-05",
                    "explored": false
                }
            ],
            "trends": {
                "vs_last_period": {
                    "concepts_touched": "+3",
                    "avg_level": "+0.3",
                    "correct_rate": "+0.12"
                }
            },
            "skipped_concepts": [
                {
                    "concept_id": "kubernetes-hpa",
                    "skip_count": 3,
                    "last_skipped": "2026-01-06"
                }
            ]
        }

    호스트 LLM 역할:
    - 이 데이터를 받아서 자연어 리포트 생성
    - weak_areas 기반으로 학습 추천
    - unknown_unknowns로 "모르는 걸 몰랐던 것" 알려줌
    - 면접 예상 질문 생성
    """

@mcp.tool()
async def get_unknown_unknowns(
    period: str = "month",
    limit: int = 10
) -> dict:
    """
    Unknown Unknowns 조회 - 스쳐 지나갔지만 탐색 안 한 개념들.

    Args:
        period: "week", "month", "all"
        limit: 반환할 최대 개수

    Returns:
        {
            "period": "month",
            "unknowns": [
                {
                    "concept_id": "cache-stampede",
                    "related_to": "cache-aside",      -- 어떤 개념과 관련되어 등장했나
                    "appearances": 5,                  -- 관련 코드 등장 횟수
                    "explored": false,                 -- 탐색 여부
                    "priority": "high",                -- high/medium/low
                    "context": "Redis 캐싱 구현 시 등장",
                    "why_important": "트래픽 많으면 DB 죽을 수 있음"
                },
                {
                    "concept_id": "connection-pooling",
                    "related_to": "database",
                    "appearances": 4,
                    "explored": false,
                    "priority": "high",
                    "context": "DB 연결 코드에서 등장",
                    "why_important": "연결 관리 최적화 필요"
                },
                ...
            ],
            "total_count": 12,
            "explored_this_period": 3
        }

    우선순위 계산:
        high: appearances >= 3 AND explored = false
        medium: appearances >= 2 AND explored = false
        low: appearances = 1 AND explored = false
    """

@mcp.tool()
async def get_due_reviews(limit: int = 5) -> list:
    """
    복습 필요한 개념 목록.

    Returns:
        [
            {
                "concept_id": "jwt-refresh-token",
                "current_level": 2,
                "days_overdue": 3,
                "last_result": "partial"
            },
            ...
        ]
    """

@mcp.tool()
async def get_mode() -> dict:
    """
    현재 학습 모드 조회.

    Returns:
        {
            "mode": "after",           -- "after", "before", "off"
            "paused_until": null,      -- 일시정지 종료 시간 (없으면 null)
            "focus_area": null         -- 집중 영역 (없으면 null)
        }
    """

@mcp.tool()
async def set_mode(
    mode: Literal["after", "before", "off"],
    paused_until: Optional[datetime] = None,
    focus_area: Optional[str] = None
) -> dict:
    """
    학습 모드 설정. Plugin에서 호출.

    Returns:
        {
            "updated": true,
            "mode": "off",
            "message": "학습 모드가 Off로 변경되었습니다."
        }
    """
```

**핵심 설계 원칙:**

```
┌─────────────────────────────────────────────────────────────┐
│              템플릿 없는 설계                                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  ❌ 기존: MCP가 question_templates, key_points 저장         │
│     → Cold Start 문제 (450개 항목 수동 작성)                │
│                                                              │
│  ✅ 새로운: MCP는 레벨과 기록만 저장                        │
│     → 질문 생성: 호스트 LLM이 작업 요약 보고 직접 생성      │
│     → 답변 평가: 호스트 LLM이 직접 판단                     │
│     → Cold Start 없음                                       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**concept_id 자유 생성:**

```
Claude: "이 코드는 Cache-Aside 패턴이네"
      → concept_id = "cache-aside" (자유 생성)

MCP: get_concept_level("cache-aside")
   → 없으면 자동 생성, level=1 반환
   → 있으면 현재 level 반환

중복 문제?
→ "cache-aside"와 "lazy-loading"이 같은 개념이어도 상관없음
→ 둘 다 학습하면 됨. 완벽한 정규화보다 학습 기회가 중요
```

### 호스트(Claude)가 할 일

MCP는 숫자만 제공합니다. 실제 학습은 호스트가 만듭니다:

```
┌─────────────────────────────────────────────────────────────┐
│                   호스트의 책임                              │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. 작업 요약 생성 (기존 패턴)                              │
│     "📋 UserService에 Redis 캐싱 추가, Cache-Aside..."     │
│                                                              │
│  2. 요약에서 핵심 개념 추출                                 │
│     "Cache-Aside" → concept_id = "cache-aside"              │
│                                                              │
│  3. 레벨에 맞는 질문 직접 생성                              │
│     Level 1: "Cache-Aside가 뭔지 아세요?"                   │
│     Level 3: "언제 Write-Through를 대신 쓰나요?"            │
│                                                              │
│  4. 답변 직접 평가                                          │
│     "캐시 먼저 보고 없으면 DB" → correct                    │
│     의심스러우면 관대하게 (학습 촉진이 목표)                │
│                                                              │
│  5. 자연스러운 대화                                         │
│     요약 끝에 질문 자연스럽게 붙이기                        │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 데이터 모델 (단순화)

```python
@dataclass
class LearningRecord:
    id: int
    concept_id: str  # 호스트 LLM이 자유 생성
    timestamp: datetime
    level: int  # 1-5
    result: str  # "correct", "partial", "incorrect", "skipped"

@dataclass
class ConceptProgress:
    concept_id: str  # PK, 자동 생성됨
    current_level: int  # 1-5
    easiness_factor: float  # SM-2 (기본값 2.5)
    interval_days: int
    next_review: date
    total_attempts: int
    correct_count: int

# Concept 테이블 불필요 - 호스트 LLM이 자유롭게 생성
# question_templates 불필요 - 호스트 LLM이 직접 생성
# key_points 불필요 - 호스트 LLM이 직접 평가
```

### 통합 흐름: 작업 요약 기반 시퀀스

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        After 모드 전체 시퀀스                            │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  사용자                    호스트(Claude)              VibeLearning MCP  │
│    │                           │                            │           │
│    │ "Redis 캐싱 구현해줘"     │                            │           │
│    │ ─────────────────────────>│                            │           │
│    │                           │                            │           │
│    │                           │ [작업 수행]                │           │
│    │                           │ - user.ts 수정             │           │
│    │                           │ - redis.ts 생성            │           │
│    │                           │ - 테스트 추가              │           │
│    │                           │                            │           │
│    │                           │ [작업 요약 생성]           │           │
│    │                           │ "Cache-Aside 패턴 적용..." │           │
│    │                           │                            │           │
│    │                           │ should_ask_question()      │           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"should_ask": true}       │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │                           │ [요약에서 개념 추출]       │           │
│    │                           │ → "cache-aside"            │           │
│    │                           │                            │           │
│    │                           │ get_concept_level          │           │
│    │                           │ ("cache-aside")            │           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"current_level": 1}       │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │ "완료!                    │                            │           │
│    │  📋 작업 요약: ...        │                            │           │
│    │  💡 혹시 Cache-Aside가   │                            │           │
│    │     뭔지 아세요?"        │                            │           │
│    │ <─────────────────────────│                            │           │
│    │                           │                            │           │
│    │ "캐시 먼저 보고 없으면   │                            │           │
│    │  DB에서 가져오는 거요"   │                            │           │
│    │ ─────────────────────────>│                            │           │
│    │                           │                            │           │
│    │                           │ [답변 평가: correct]       │           │
│    │                           │                            │           │
│    │                           │ record_learning            │           │
│    │                           │ ("cache-aside", 1, correct)│           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"new_level": 2}           │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │ "맞아요! 다음엔 다른     │                            │           │
│    │  캐싱 전략과 비교해볼게요"│                            │           │
│    │ <─────────────────────────│                            │           │
│    │                           │                            │           │
└─────────────────────────────────────────────────────────────────────────┘
```

### 스킵 시 흐름

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        스킵 처리 시퀀스                                  │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  사용자                    호스트(Claude)              VibeLearning MCP  │
│    │                           │                            │           │
│    │ "스킵" / (무시)           │                            │           │
│    │ ─────────────────────────>│                            │           │
│    │                           │                            │           │
│    │                           │ record_learning            │           │
│    │                           │ ("cache-aside", 1, skipped)│           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"consecutive_skips": 2}   │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │ "알겠어요! 이번에는      │                            │           │
│    │  쉴게요."                │                            │           │
│    │ <─────────────────────────│                            │           │
│    │                           │                            │           │
└─────────────────────────────────────────────────────────────────────────┘
```

### Before 모드 시퀀스

```
┌─────────────────────────────────────────────────────────────────────────┐
│                        Before 모드 시퀀스                                │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                          │
│  사용자                    호스트(Claude)              VibeLearning MCP  │
│    │                           │                            │           │
│    │ "JWT 인증 구현해줘"       │                            │           │
│    │ ─────────────────────────>│                            │           │
│    │                           │                            │           │
│    │                           │ [Before 모드 활성화 확인]  │           │
│    │                           │                            │           │
│    │                           │ get_concept_level("jwt")   │           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"current_level": 1}       │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │ "구현 전에, JWT와        │                            │           │
│    │  세션 인증의 차이가      │                            │           │
│    │  뭘까요?                 │                            │           │
│    │  ('그냥 구현해줘' 하면   │                            │           │
│    │   바로 넘어갈게요)"      │                            │           │
│    │ <─────────────────────────│                            │           │
│    │                           │                            │           │
│    │ "stateless라서 서버에    │                            │           │
│    │  세션 저장 안 해도 됨"   │                            │           │
│    │ ─────────────────────────>│                            │           │
│    │                           │                            │           │
│    │                           │ [평가: correct]            │           │
│    │                           │                            │           │
│    │                           │ record_learning            │           │
│    │                           │ ("jwt", 1, correct)        │           │
│    │                           │ ──────────────────────────>│           │
│    │                           │ {"new_level": 2}           │           │
│    │                           │ <──────────────────────────│           │
│    │                           │                            │           │
│    │ "맞아요! 이제 구현할게요"│                            │           │
│    │ <─────────────────────────│                            │           │
│    │                           │                            │           │
│    │                           │ [작업 수행]                │           │
│    │                           │                            │           │
└─────────────────────────────────────────────────────────────────────────┘
```

**Before 모드 핵심:**
- 구현 전에 이해도 확인
- "그냥 구현해줘" 하면 즉시 스킵 (절대 블로킹 안 함)
- 틀려도 설명 후 구현 진행

### 호스트 통합 가이드 (CLAUDE.md 예시)

```markdown
# VibeLearning 통합 가이드

## 트리거 시점

**작업 완료 후 요약 생성 시** 학습 체크를 수행합니다.

## 흐름

1. **작업 완료 → 요약 생성** (기존 패턴 그대로)

2. **요약에서 핵심 개념 추출**
   - "Cache-Aside 패턴 적용" → concept_id = "cache-aside"
   - 정규화: lowercase, 공백→하이픈

3. **질문 여부 확인**
   ```
   should_ask_question() 호출
   → should_ask=false면 요약만 전달
   ```

4. **레벨 확인**
   ```
   get_concept_level("cache-aside") 호출
   → {"current_level": 1}
   ```

5. **레벨에 맞는 질문 직접 생성**
   - Level 1: "~가 뭔지 아세요?"
   - Level 2: "~가 어떻게 작동하나요?"
   - Level 3: "언제 ~을 대신 쓰나요?"
   - Level 4: "~의 문제점은?"
   - Level 5: "~ 설계해보세요"

6. **답변 직접 평가**
   - correct: 이해를 보여주면 관대하게
   - partial: 방향은 맞지만 불완전
   - incorrect: 명확히 틀림
   - **원칙: 의심스러우면 correct**

7. **결과 기록**
   ```
   record_learning("cache-aside", level, result) 호출
   ```

## 요약에 질문 붙이기

```
"완료했습니다!

📋 작업 요약:
• UserService에 Redis 캐싱 추가
• Cache-Aside 패턴 적용
• TTL 1시간 설정

💡 혹시 Cache-Aside 패턴이 뭔지 아세요?"
```

## 주의

- 단순 작업(오타 수정, 포매팅)은 질문 안 함
- "스킵" 또는 무응답 시 즉시 수용, 페널티 없음
- 연속 2회 스킵 시 해당 세션 질문 중단
```

### SQLite 스키마 (단순화)

```sql
-- concepts 테이블 불필요 (호스트 LLM이 자유 생성)
-- question_templates 불필요 (호스트 LLM이 직접 생성)
-- key_points 불필요 (호스트 LLM이 직접 평가)

-- 개념별 진행 상태 (자동 생성됨)
CREATE TABLE concept_progress (
    concept_id TEXT PRIMARY KEY,      -- 호스트 LLM이 자유 생성
    current_level INTEGER DEFAULT 1,
    easiness_factor REAL DEFAULT 2.5, -- SM-2 E-Factor
    interval_days INTEGER DEFAULT 1,
    next_review DATE,
    total_attempts INTEGER DEFAULT 0,
    correct_count INTEGER DEFAULT 0,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 학습 기록
CREATE TABLE learning_records (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    concept_id TEXT,
    level INTEGER,
    result TEXT CHECK(result IN ('correct', 'partial', 'incorrect', 'skipped')),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 세션 상태
CREATE TABLE session_state (
    id INTEGER PRIMARY KEY CHECK(id = 1),
    questions_today INTEGER DEFAULT 0,
    last_question_at TIMESTAMP,
    consecutive_skips INTEGER DEFAULT 0
);

-- 모드 상태 (Plugin에서 set_mode 호출 시 업데이트)
CREATE TABLE mode_state (
    id INTEGER PRIMARY KEY CHECK(id = 1),
    mode TEXT DEFAULT 'after' CHECK(mode IN ('after', 'before', 'off')),
    paused_until TIMESTAMP,
    focus_area TEXT
);

-- Unknown Unknowns 추적 (NEW)
CREATE TABLE unknown_unknowns (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    concept_id TEXT,                      -- 탐색 안 한 개념 (예: cache-stampede)
    related_to TEXT,                       -- 관련된 개념 (예: cache-aside)
    appearances INTEGER DEFAULT 1,         -- 관련 코드 등장 횟수
    explored BOOLEAN DEFAULT FALSE,        -- 탐색 여부
    context TEXT,                          -- 어떤 상황에서 등장했나
    why_important TEXT,                    -- 왜 중요한지 (호스트 LLM이 생성)
    first_seen TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    explored_at TIMESTAMP                  -- 탐색한 시간 (NULL이면 미탐색)
);

-- 인덱스
CREATE INDEX idx_records_concept ON learning_records(concept_id);
CREATE INDEX idx_progress_review ON concept_progress(next_review);
CREATE INDEX idx_unknowns_explored ON unknown_unknowns(explored);
CREATE INDEX idx_unknowns_related ON unknown_unknowns(related_to);
```

### Plugin 아키텍처

MCP 서버만으로도 작동하지만, **Plugin을 통해 더 나은 UX**를 제공합니다:

```
┌─────────────────────────────────────────────────────────────┐
│                    MCP vs Plugin 역할 분리                   │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│   MCP Server (결정론적)           Plugin (사용자 인터랙션)  │
│   ─────────────────────           ─────────────────────────  │
│   • get_mode / set_mode           • /learn 슬래시 명령어    │
│   • 모드 상태 저장                • 모드 전환 UI            │
│   • 피로도 계산                   • 상태바 표시             │
│   • SM-2 계산                     • 알림/토스트             │
│   • 통계 쿼리                     • 설정 화면               │
│                                                              │
│   ✅ 상태 없음, 순수 계산         ✅ 사용자 경험 담당       │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**Plugin 슬래시 명령어:**

```
# 모드 제어
/learn              → 현재 상태 표시 + 메뉴
/learn pause        → 1시간 일시 정지 (set_mode 호출)
/learn off          → 학습 끄기 (기록은 계속됨)
/learn before       → Before 모드 활성화
/learn after        → After 모드 (기본)
/learn senior       → 시니어 모드 활성화 (반론 설득 필요) ← NEW
/learn senior light → 시니어 라이트 (설득 안 해도 진행, 피드백만)
/learn focus auth   → 인증 관련만 질문

# 기능 (모든 모드에서 사용 가능)
/learn stats        → 통계 대시보드 (get_stats 호출)
/learn report       → 주간 학습 리포트 (get_report_data 호출)
/learn report month → 월간 리포트
/learn report auth  → 인증 영역만 리포트
/learn report --save → md 파일로 저장
/learn unknowns     → Unknown Unknowns 대시보드 (get_unknown_unknowns 호출) ← NEW
/learn unknowns --save → md 파일로 저장
/learn review       → 밀린 복습 시작 (get_due_reviews 호출)
/learn interview    → 면접 연습 시작
```

**리포트 생성 흐름:**

```
┌─────────────────────────────────────────────────────────────┐
│                    /learn report 실행                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. Plugin: 명령어 파싱                                     │
│       ↓                                                     │
│  2. MCP: get_report_data(period="week") 호출               │
│       ↓                                                     │
│  3. MCP: 학습 기록 집계, 패턴 분석, JSON 반환              │
│       ↓                                                     │
│  4. Plugin → 호스트 LLM: "이 데이터로 리포트 생성해줘"     │
│       ↓                                                     │
│  5. 호스트 LLM: 자연어 리포트 생성                         │
│       ↓                                                     │
│  6. 사용자에게 표시 (또는 --save면 md 파일 저장)           │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**왜 분리하는가:**

| MCP만 사용 | MCP + Plugin |
|-----------|--------------|
| 호스트 LLM이 모드 관리 | 사용자가 직접 제어 |
| 명령어 없음 | `/learn` 슬래시 명령 |
| 상태바 없음 | 현재 모드 표시 |
| 설정 대화로 | 설정 UI 제공 |

**Plugin 없이도 작동:**

```
사용자: "학습 모드 꺼줘"
Claude: (set_mode("off") 호출)
       "학습 모드를 껐어요. 다시 켜려면 말씀해주세요."
```

Plugin이 있으면 더 편리하지만, MCP만으로도 호스트 LLM을 통해 모든 기능 사용 가능.

---

## 7. 기술 스택

| 컴포넌트 | 기술 | 이유 |
|---------|------|------|
| 언어 | Python 3.11+ | MCP SDK 지원, 생태계 |
| MCP | FastMCP | 깔끔한 API |
| DB | SQLite | 로컬, 설정 불필요, 결정론적 쿼리 |
| 알고리즘 | SM-2 | Anki와 동일, 검증됨 |

**의존성:**

```
fastmcp>=0.1.0
pydantic>=2.0
sqlite3 (stdlib)
```

---

## 8. 경쟁 분석

### 핵심 차별화: 바이브 코딩 중 학습

VibeLearning의 유일한 차별점은 **"바이브 코딩 중에 학습이 일어난다"**는 것입니다.

```
┌─────────────────────────────────────────────────────────────┐
│                    학습이 일어나는 시점                       │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Anki          코딩 끝나고 → 앱 열고 → 카드 복습            │
│                (별도 시간 필요, 귀찮음)                      │
│                                                              │
│  Rember        대화하다가 → "이거 기억해줘" → 카드 생성     │
│                (코딩 에이전트가 아님, 수동 요청)            │
│                                                              │
│  VibeLearning  코드 짜는 중 → 자동으로 질문 → 학습          │
│                (바이브 코딩 워크플로우 안에서)              │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**왜 이게 중요한가:**

```
현실: "나중에 Anki로 복습해야지" → 그 "나중"은 안 옴
현실: "시간 날 때 공부해야지" → 그 시간은 없음

VibeLearning: 바이브 코딩하면서 자연스럽게 학습
             별도 시간 투자 없이 성장
```

### 카테고리가 다름: AI 코딩 에이전트 플러그인

VibeLearning은 **Claude Code, OpenCode 같은 AI 코딩 에이전트의 MCP/플러그인**입니다.

```
┌─────────────────────────────────────────────────────────────┐
│                      카테고리 비교                           │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  도구              카테고리              코딩 중 학습?       │
│  ───────────────   ───────────────────   ─────────────────  │
│  Anki              범용 플래시카드 앱    ❌ 별도 앱          │
│  Rember MCP        Claude Desktop용      ❌ 코딩 에이전트 X │
│  LeetCode          알고리즘 학습 사이트  ❌ 실무와 분리     │
│  VibeLearning      코딩 에이전트 플러그인 ✅ 바이브 코딩 중  │
│                                                              │
│  VibeLearning이 동작하는 곳:                                 │
│  • Claude Code (Anthropic 공식 CLI)                         │
│  • OpenCode (오픈소스 코딩 에이전트)                        │
│  • Cursor, Windsurf 등 MCP 지원 에이전트                    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

Anki, Rember와 비교하는 것 자체가 맞지 않습니다. **카테고리가 다릅니다.**

### claude-mem vs VibeLearning

"claude-mem 같은 메모리 도구로 충분하지 않아?"

```
┌─────────────────────────────────────────────────────────────┐
│                    핵심 차이                                 │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  claude-mem: "이런 작업 했어요" (기록)                      │
│  VibeLearning: "이 중에서 당신이 모르는 건 이거예요" (검증) │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**실제 시나리오:**

```
[claude-mem에게]
유저: "학습해야 할 부분 말해줘"
→ "Spring REST Docs, Feign Client 심화..."
   (이미 다 아는데 공부하라고 함 ❌)

[VibeLearning]
유저: "학습해야 할 부분 말해줘"
→ "Cache Stampede - 3번 나왔는데 매번 스킵함"
→ "JWT 무효화 - 질문했을 때 partial만 받음"
   (실제로 모르는 것만 ✅)
```

| 기능 | claude-mem | VibeLearning |
|------|------------|--------------|
| 작업 기록 | ✅ 무엇을 했는지 | ✅ |
| 이해도 검증 | ❌ 아는지 모르는지 모름 | ✅ 질문으로 확인 |
| 학습 추천 | ❌ 추측만 가능 | ✅ 데이터 기반 |
| 복습 시점 | ❌ 언제 복습할지 모름 | ✅ SM-2로 계산 |

**핵심:** claude-mem은 "했다"를 기록, VibeLearning은 "안다"를 검증.

### Claude 단독 vs VibeLearning

같은 코딩 에이전트 안에서의 비교입니다. "그냥 Claude한테 물어보면 되잖아?"

```
┌─────────────────────────────────────────────────────────────┐
│              Claude 단독 vs VibeLearning MCP                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Claude 단독으로 가능                                        │
│  ─────────────────────────────────────────────────────────  │
│  ✅ "이 코드 설명해줘" → 설명                               │
│  ✅ "퀴즈 내줘" → 퀴즈 생성                                 │
│  ✅ "Cache-Aside가 뭐야?" → 답변                            │
│                                                              │
│  Claude 단독으로 불가능 (세션 간 기억 없음)                 │
│  ─────────────────────────────────────────────────────────  │
│  ❌ "3주 전에 JWT 배웠는데, 복습할까요?"                    │
│  ❌ "캐싱은 5번 다뤘는데 아직 Level 2예요"                  │
│  ❌ "이번 달 정답률 73%, 지난달보다 +12%"                   │
│  ❌ "JWT 나올 때마다 스킵하시네요"                          │
│  ❌ "인증 영역이 3주째 정체 중"                             │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

**핵심 차이:**

| 상황 | Claude 단독 | VibeLearning |
|-----|------------|--------------|
| "3주 전에 뭐 배웠지?" | 모름 | 기록 있음 |
| "복습해야 할 거 있어?" | 모름 | SM-2가 알려줌 |
| "내 캐싱 실력 어느 정도야?" | "잘하시는 것 같아요" (추측) | "78%, Level 3" (데이터) |
| "왜 인증이 안 느는 거지?" | 모름 | "JWT 나올 때마다 스킵함" |
| "나 성장하고 있어?" | "열심히 하시네요" (위로) | "+23% 3개월간" (증거) |

Claude는 **일회성 인사이트**, VibeLearning은 **누적 학습 + 리마인드**.

### Unknown Unknowns: 모르는 걸 모르는 문제

```
┌─────────────────────────────────────────────────────────────┐
│                                                              │
│   모른다는 걸 아는 것          모른다는 것도 모르는 것      │
│   (Known Unknowns)             (Unknown Unknowns)           │
│   ┌─────────────┐              ┌─────────────────────┐      │
│   │             │              │                      │      │
│   │  "JWT 뭐야?"│              │  "Cache Stampede"를  │      │
│   │  물어볼 수  │              │  모르면 질문할 수    │      │
│   │  있음       │              │  조차 없음           │      │
│   │             │              │                      │      │
│   └─────────────┘              └─────────────────────┘      │
│                                       ↑                      │
│                                 VibeLearning이               │
│                                 이걸 잡아냄                  │
│                                                              │
│   VibeLearning: "Cache-Aside 쓰셨네요.                      │
│                  Cache Stampede는 아세요?"                  │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 진짜 경쟁자

VibeLearning의 진짜 경쟁자는 다른 도구가 아닙니다:

```
1. "그냥 코드 받고 끝"
   → 대부분 물어보지도 않음. 작동하면 넘어감.

2. "나중에 공부해야지"
   → 그 "나중"은 안 옴

3. "아무것도 안 함" (관성)
   → 가장 큰 경쟁자
```

VibeLearning의 가치:
- **"코드 받고 끝"이 아니라 "코드 받고 + 학습"**
- **"나중에"가 아니라 "지금, 코딩하면서"**

### 포지셔닝

```
┌─────────────────────────────────────────────────────────────┐
│           AI 코딩 에이전트 생태계에서의 위치                │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  Claude Code / OpenCode / Cursor                            │
│  └─ 코드 생성 (빠름, 편함)                                  │
│     └─ 문제: 개발자가 성장하는지 모름                       │
│                                                              │
│  + VibeLearning MCP                                          │
│    └─ 코드 생성 + 학습 확인 + 복습 리마인드 + 성장 추적    │
│       └─ 바이브 코딩의 단점을 보완                          │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

### 한 줄 요약

```
VibeLearning = AI 코딩 에이전트에 "학습 레이어"를 추가하는 MCP

바이브 코딩의 속도는 유지하면서,
개발자의 성장도 함께 챙긴다.
```

---

## 9. 로드맵

### Phase 0: 개념 증명 (3일)

**목표:** 핵심 아이디어가 작동하는지 검증

**범위:**
- [ ] MCP 서버 기본 구조 (6개 도구)
- [ ] SQLite 스키마 구현 (3개 테이블)
- [ ] SM-2 알고리즘 구현
- [ ] CLAUDE.md 통합 가이드 작성
- [ ] 기본 기록 기능 (Off 모드에서도 동작)

**성공 기준:**
- 직접 5회 사용
- 3회 이상 "유용했다"
- 짜증나지 않음

### Phase 1: MVP (1주)

**목표:** 일일 사용 가능한 최소 기능

**범위:**
- [ ] 피로도 관리 (should_ask_question)
- [ ] 레벨별 질문 흐름 (get_concept_level → 호스트 LLM 질문 생성)
- [ ] 학습 기록 및 복습 스케줄 (record_learning)
- [ ] 기본 `/learn stats` (get_stats)
- [ ] **`/learn report` 주간 리포트** (get_report_data)
- [ ] After 모드 완성
- [ ] Off 모드 + 리포트 조합 검증

**MVP에 없는 것:**
- ❌ Before 모드
- ❌ 면접 준비
- ❌ 영역별 상세 그룹핑
- ❌ 리포트 md 파일 저장 (--save)

### Phase 2: 학습 루프 완성 (1주)

**목표:** 복습 시스템 + Unknown Unknowns 시각화

**범위:**
- [ ] 복습 필요 개념 조회 (get_due_reviews)
- [ ] 영역별 통계 (호스트 LLM이 태그 전달)
- [ ] 피로도 자동 조정 고도화
- [ ] 스킵 패턴 분석
- [ ] **월간 리포트** (/learn report month)
- [ ] **리포트 md 저장** (--save 옵션)
- [ ] **`/learn unknowns` 대시보드** (get_unknown_unknowns) ← NEW
- [ ] 관련 개념 연결 로직 (cache-aside → cache-stampede 등)
- [ ] 탐색 유도 흐름 구현

### Phase 3: 완성 (1주)

**목표:** 공개 준비

**범위:**
- [ ] Before 모드
- [ ] **시니어 모드** (/learn senior) ← NEW
- [ ] 면접 준비 기능 (/learn interview)
- [ ] **영역별 리포트** (/learn report auth)
- [ ] pip 패키지
- [ ] 문서화 및 예제

### 타임라인

```
Phase 0: 3일   ███
Phase 1: 1주   ███████
Phase 2: 1주   ███████
Phase 3: 1주   ███████

내부 사용 가능: Phase 1 완료 후 (~10일)
공개 가능: Phase 3 완료 후 (~4주)
```

---

## 10. 열린 질문들

### 제품

1. **게이미피케이션**: 스트릭, 배지 추가할까? (과하면 역효과)
2. **팀 기능**: 필요한가? 어떤 형태로?
3. **다국어 지원**: 영어/한국어 질문 생성 분리?

### 기술

1. **프라이버시**: 전부 로컬만? 선택적 클라우드 동기화?
2. **다중 프로젝트**: 프로젝트별 학습 기록 분리할까?
3. **호스트 호환성**: Claude Code 외 Cursor, Windsurf 테스트 필요

### 시장

1. **출시 플랫폼**: Product Hunt? Hacker News?
2. **이름**: VibeLearning 유지? 다른 이름?

### 이미 결정된 것 (참고용)

| 질문 | 결정 | 근거 |
|------|------|------|
| 개념 데이터베이스 | 호스트 LLM 자유 생성 | Cold Start 해결 |
| 질문 생성 방식 | 호스트 LLM 직접 생성 | 템플릿 유지보수 부담 제거 |
| 답변 평가 방식 | 호스트 LLM 직접 평가 | 의미 기반 평가 필요 |
| 트리거 시점 | 작업 요약 후 | 자연스러운 흐름 |
| 세션 정의 | 프로젝트 단위 | claude.json 기준 |

---

## 다음 단계

1. [ ] Phase 0 시작: MCP 서버 기본 구조 (9개 도구)
2. [ ] SQLite 스키마 구현 및 SM-2 알고리즘
3. [ ] Unknown Unknowns 테이블 및 추적 로직
4. [ ] CLAUDE.md 통합 가이드 작성
5. [ ] 1주일 직접 사용 (dogfooding)
6. [ ] 피드백 기반 반복

---

*최종 업데이트: 2026년 1월*
